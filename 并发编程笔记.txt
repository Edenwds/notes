1. 如何减少线程的上下文切换？
      无锁并发编程：多线程竞争锁时，会引起上下文切换。可以使用算法，是不同的线程专门处理不同的数据，减少上下文的切换。  
	  CAS算法：java使用Atomic包使用CAS算法更新数据，不需要加锁	  
	  使用最少线程：避免创建不必要的线程 
	  协程：在单线程中实现多任务的调度，并在单线程里维持多个任务间的切换
	  
2. volatile轻量级的synchronized，在多处理器中保证了共享变量的“可见性”，防止指令重排序，但是不能保证数据的安全性，对数据的操作不是原子的。
	volatile在计算机内部实现的两条原则:
		Lock前缀指令会引起处理器缓存写回内存
		一个处理器的缓存写回内存会导致其他处理器的缓存失效
		
3. synchronized用的锁是存在java对象头中。
	锁共有四种状态： 无锁状态   偏向锁    轻量级锁   重量级锁   
	这几种锁状态会随着竞争情况逐渐升级，锁可以升级但不能降级，目的是为了提高获取和释放锁的效率。
	
	偏向锁： 当一个线程访问同步代码块并获取锁时，会在对象头和栈帧中的锁记录中存储锁偏向的线程ID,以后该线程在进入和退出同步代码块时不需要进行CAS操作来加锁和解锁。只需要简单测试下对象头的Mark World里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获取锁。如果测试失败，则需要再测试下Mark World中偏向锁的标识是否设置为1，如果没有设置，则使用CAS竞争锁，设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
	
	轻量级锁：
	加锁：线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark World复制到锁记录中，然后线程尝试使用CAS将对象头中Mark World替换为指向锁记录的指针。如果成功，当前线程获得锁，失败，表示有其他线程竞争锁，当前线程使用自旋的方式来获取锁。
	解锁：会使用CAS将锁记录中记录的Mark World（Displaced Mark World）替换回到对象头，如果成功，则表示没有锁竞争，失败则锁膨胀为重量级锁。
	
4. 原子操作
	java中可以通过锁和循环CAS的方式来实现原子操作。
	
	CAS实现原子操作的问题：
		ABA问题：java1.5开始，提供了AtomicStampedReference来解决ABA问题。
		循环时间长开销大
		只能保证一个共享变量的原子操作
		
	以锁的方式实现操作的原子性，在java的多种锁中，除了偏向锁，其他锁的获取与释放都使用循环CAS的方式	
5. java内存模型
	在并发编程中，需要处理的两个关键问题：线程间如何通信 及 线程间如何同步
	在命令式编程中，线程的通信机制有 共享内存和消息传递。
	
	java的并发采用的是共享内存的通信方式，java线程之间的通信总是隐式进行。
	
6. 指令重排序
	分为三类：编译器优化的重排序     指令级并行的重排序    内存系统的重排序  其中第一个属于编译器重排序，后两个属于处理器重排序。
	指令重排序可能会导致多线程程序出现内存可见性的问题。
	对于编译器，JMM的编译器排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。
	
	happens-before：两个操作有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行，仅要求前一个操作的执行结果对后一个操作可见，且前一个操作按顺序排在第二个操作之前。
	
7. ReetrantLock的实现依赖于同步框架AbstarctQueueSynchronizer(AQS)，AQS使用一个整型的volatile变量来维护同步状态。
	公平锁和非公平锁的内存语义：
	公平锁和非公平锁释放时，最后都要写一个volatile变量
	公平锁获取时，首先会读volatile变量
	非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义、
	
8. final域的重排序规则
	对于final，编译器和处理器要遵守两个重排序规则。
	在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
	
	初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。
	
	读final域的重排序规则可以确保: 在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。
	
9. java语言规范规定，对于一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM自由实现。
	对比基于volatile的双重检查锁和基于类初始化实现延迟初始化的方案，我们发现基于类初始化的方案的实现代码更简洁。但基于volatile的双重检查锁的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段延迟初始化。
	
	需要对实例字段使用线程安全的延迟初始化，使用基于volatile的延迟初始化方案。
	需要对静态字段使用线程安全的延迟初始化，使用基于类初始化的方案。
	
10. Daemon线程是一种支持型线程，主要用作程序中后台调度以及支持性工作。但是在java虚拟机退出时Daemon线程中的finally块并不一定会执行，所以在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。	
















	
	
	
	
		
	  
	 