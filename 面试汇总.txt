1.java基础
  1）java内存模型
     java线程之间的通信采用的共享内存模型，共享内存模型指的就是java内存模型（简称JMM），JMM决定一个线程对共享变量的写入何时对另一个线程可见，从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系，线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。

     java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，volatile的特殊 规则保证了新值能立即同步到主内存，以及每次用前立即从主内存刷新

--------------------------------------------------------------------------------------------------- 
  2）多态（重载重写）

     重载：编译时的多态性

        为什么不能根据返回值类型区分重载？
         因为调用的时不能指定类型信息，编译器不知道你要调用哪个函数   
      
     重写：运行时的多态性



     重写 两同两小一大原则：
     方法名相同，参数类型相同

     子类返回类型小于等于父类返回类型

     子类抛出异常小于等于父类抛出异常

     子类访问权限大于等于父类方法访问权限

     子类无法覆盖父类的static方法或private方法


     普通方法，运用的是动态单分配，是根据new的类型确定对象，从而确定调用的方法
     静态方法，运用的是静态单分配，即根据静态类型确定对象，因此不是根据new类型确定调用的方法
     
     成员变量：编译运行都参考左边
     成员函数（非静态）：编译看左边，运行看右边
     静态函数： 编译运行都看左边   

    构造器是否能够被重写？
     构造器不能被继承，所以不能被重写，但是可以重载  

--------------------------------------------------------------------------------------------------- 
  3）object方法

     hashcode()
     equals()
     toString()
     wait()
     notify()
     notifyAll()
     getClass()
     clone()
     finalize()

     为什么wait notify  notifyAll是object的方法
     因为它们都是操作锁的，而每个对象都有锁，锁是每个对象的基础。所以是属于object的
       


--------------------------------------------------------------------------------------------------- 
  4）类访问权限
     public 所有都可以访问
     protect 同一个包中 和 子类
     default  只能同一个包中
     private  本身类


--------------------------------------------------------------------------------------------------- 
  5）sleep notify wait联系 区别
     
     wait()允许我们将线程置入“睡眠状态”，同时又“积极”地等待条件发生改变，而且只有一个notify()或notifyAll()发生变化地时候，线程才会被唤醒，并检查条件是否有变---Thinking in JAVA
     
     wait 将当前线程阻塞，这点和sleep或者是suspend是相同的，区别是：
     wait可以自己唤醒，而sleep和suspend无法做到，因为同步时，需要锁定对象，获取对象锁，其它要使用该对象锁的线程都只能排队，在同步方法和同步块中，sleep和suspend都不能自己被调用的时候解除锁定，而wait可以，可以让同步方法或这同步块暂时放弃对象锁，必须收回，方法 wait中设置时间限制，或者获得notify或者notifyAll的 通知



--------------------------------------------------------------------------------------------------- 
  6）String stringbuffer stringbuilder联系、区别、源码
     
     在String类中，使用final字符数组保存字符串，private final char value[]   final修饰不可变类型  

     String重写equals()方法  在方法中，先比较是否为同一个对象，若是，则返回true；若不是，则先判断是否为String类型，再逐个字符比较


     StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串的，char[]value 这两种对象都是可变的

     String是不可变类，任何对String的改变都会引发新的String的对象生成，而StringBuffer是可变类，任何对它所指代的字符串的改变都不会产生新的对象。
     StringBuffer 是线程安全的，StringBuilder是非线程安全的，在单线程时，StringBuilder比StringBuffer速度快
 

---------------------------------------------------------------------------------------------------     
  7）Volatile原理 源码 与synchronized区别

     volatile并不能保证线程的安全性，即原子性
            修饰的变量不会被指令重排序优化
            主要用在多个线程感知实例变量被更改了场合，从而使各个线程获得最新的值，保证了数据的可见性。

     在jvm中 保证volatile是保证 read和load命令  write和store命令连续执行 使用变量从内存重新加载  改变变量立即同步回内存

     区别：volatile轻量级，只能修饰变量，synchronized重量级，还可以修饰方法
           volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞
           synchronized不仅保证可见性，而且还保证原子性，


--------------------------------------------------------------------------------------------------- 
  8）线程间的通信方式
     1.同步
       多个线程通过synchronized关键字来实现线程之间的通信，本质是“共享内存”式的通信，多个线程需要访问同一个共享变量，谁拿到锁，就可以执行

       线程的同步机制：临界区，互斥量，事件，信号量四种方式
       临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问
       互斥量：采用互斥对象机制
       信号量：允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数
       事件： 通过通知操作的方式来保持线程的同步，还可以方便实现多个线程的优先级比较操作

     2.while轮询
    
     3.wait/notify机制
  
     4.管道通信



    线程的同步： 临界区  事件  信号量  互斥

    线程安全： synchronized修饰方法 代码块

               Lock API

               volatile

               threadlocal

--------------------------------------------------------------------------------------------------- 
  9）线程的各种状态
     新建 就绪 运行 阻塞 死亡
     

     进程的状态: 就绪  运行  阻塞

 

--------------------------------------------------------------------------------------------------- 
2.集合框架
  List  元素可以重复  有序

  if(list!=null&&list.size()!=0){} else{}

  判断list和判断list.size()和list.isEmpty()的不同：
   新建一个list对象，默认值是空，而非null
   即list是否为null，判断的是list是否创建 是否存在。
   list.size()==0和list.isEmpty()用于判断list中的内容是否为空，即表里一个元素也没有，但使用的前提是list是一个空集合，而不是null，所以为了避免异常，建议在使用或赋值list集合之前，做一次空集合创建处理，进行内存空间分配处理，即 List list=new ArrayList()



---------------------------------------------------------------------------------------------------    
  1）ArrayList
    ArrayList是List接口的一个具体实现类，底层数据结构是数组结构，相当于一个动态数组，特点是随机查询速度快，增删慢（因为要移动数据），线程不安全，继承自AbstractList  默认容量为10 会自动扩容,扩大为原来的1.5倍

    更适合检索和在末尾插入或删除（数组的特性）
--------------------------------------------------------------------------------------------------- 
  2)LinkedList
    LinkedList底层数据结构为双向链表结构，可以当成堆栈或者队列使用，特点是：增删速度快，顺序查询效率较高，随机查询稍慢（因为要移动指针），继承自AbstractSequentialList  不存在扩容增量问题  线程不安全

    更适合从中间插入或者删除（链表的特性）
--------------------------------------------------------------------------------------------------- 
  3)Vector
    vector是线程安全的 通过synchronized实现的

    vector类提供了实现可增长数组的功能，随着更多元素加入其中，数组变得更大，在删除一些元素后，数组变小。
   三者区别 联系 源码


   如果只是查找特定位置的元素或只在集合的末端增加，移除元素，那么使用vector和ArrayList都可以，如果是对其它指定位置的插入、删除操作，最好选择LinkledList

   源码分析：
    ArrayList想要get(int index)元素时，直接返回index位置上的元素，而LinkedList需要通过for循环进行查找，虽然LinkedList已经在查找方法上做了优化，比如index<size/2，则从左边开始查找，反之从右边开始查找，但还是比ArrayList要慢

    ArrayList想要在指定位置插入或删除元素时，主要耗时的是System.arraycopy动作，会移动index后面所有的元素，LinkedList主要耗时的是要先通过for循环找到index，然后直接插入或删除，两者速度并非一定谁快谁慢

    当插入的数据量很小时，两者区别不太大，当插入的数据量大时，大约在容量的1/10之前，LinkedList会优于ArrayList，在其后就劣势于ArrayList，且越靠近后面越差
--------------------------------------------------------------------------------------------------- 
   ArrayList与LinkedList的区别
     若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。
     ArrayList的空间浪费主要体现在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每个元素都需要消耗相当的空间
     底层不同


--------------------------------------------------------------------------------------------------- 
  Set 元素不可重复  无序

  判断重复时，不是使用==运算符，而是根据equals方法，只要两个对象用equals方法比较返回true，add方法返回false。
  1）HashSet
     是接口set接口的一个具体实现类，是通过HashMap实现的，底层使用HashMap保存所有元素   为什么用HashMap？ 只用key保存set的数据，因为在Map中key的值是唯一的，所以HashSet保证元素的不可重复，使用了HashMap的key存储数据，作为底层数据结构

     不能保证元素的排列顺序，不是同步的 集合元素可以是null，但只能放一个null

     itrator（）方法返回对此set中元素进行迭代的迭代器，返回元素的顺序并不是特定的，底层调用HashMap的keySet返回所有的key，这点反映了hashSet中的所有元素都是保存在HashMap的key中，value则是使用的PRESENT对象，该对象为static final


--------------------------------------------------------------------------------------------------- 
  2)LinkedHashSet 不是线程安全的
    是根据元素的hashCode值来决定元素的存储位置，但是同时维护链表元素的次序，当遍历该集合时，LinkedHashSet将会以元素的添加顺序访问集合的元素

    LinkedHashSet通过继承HashSet，底层使用LinkedHashMap

--------------------------------------------------------------------------------------------------- 
  3)TreeSet 是SortedSet接口的唯一实现类  非线程安全的
 
    元素有序， 支持两种排序方式，自然排序（默认）和定制排序，是通过TreeMap是实现的，TreeMap的实现是红黑树算法的实现
   









--------------------------------------------------------------------------------------------------- 
  基于什么实现，内部数据结构，适用场景，源码
   
                 |――SortedSet接口――TreeSet实现类

      Set接口――|――HashSet实现类                

                 |――LinkedHashSet实现类

   关注性能，应该使用HashSet；如果需要一个有序的Set集合，应该使用TreeSet；如果需要一个Set集合保存了原始的元素插入顺序，应该使用LinkedHashSet。

--------------------------------------------------------------------------------------------------- 
  Map
  1)HashMap
    底层是哈希表数据结构允许存储null的键和值，线程不安全 可以通过keyset , entryset遍历

    HashMap存取 存时，首先调用K的hash code方法，获取哈希码，通过哈希码快速找到某个存放位置，称为bucketIndex，若hashcode相同时发生碰撞，bucketIndex也相同，取到已存储的元素，通过equals方法来比较，对象相同时替换返回旧值，对象不同，也会将这个新元素放到这个位置，通过一个单链表维护这种关系

    HashMap时采用拉链法解决哈希冲突的， 拉链法解决冲突的做法是：将所有关键字为同义词的节点链接在同一个单链表中。若选定的散列表长度为m。则可将散列表定义为一个由m 个头指针组成的指针数组T[0...m-1].凡是散列地址为i的节点，均插入到以T[i]为头指针的单链表中，T中各分量的初值均应为空指针，在拉链法中，装填因子a可以大于1 但一般均取a<=1.
    拉链法适合为规定元素的大小。

   初始容量16 装填因子 0.75  当hashmap的容量达到初始容量*装载因子时，会进行rehash操作 即扩容操作   扩大为原来的2倍  if (size++ >= threshold)  resize(2 * table.length);
  

   解决冲突的方式主要有三种：定址法，拉链法， 再散列法。HashMap采用拉链法

   Fail-Fast机制：
   HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException,这就是fail-fast策略。
   策略的实现是通过modCount域，modCount就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋值给迭代器的expectedModCount
   在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了map；modCount声明为volatile，保证线程之间修改的可见性。

   在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove方法，其他任何时间任何方式的修改，迭代器都将抛出ConcurrentModificaitonException

   迭代器的快速失败行为不能得到保证，因此编写依赖于此异常的程序的做法是错误的，正确的做法是：迭代器的快速失败行为应该仅用于检测程序错误。

---------------------------------------------------------------------------------------------------

  2)WeakHashMap  非线程安全
   
   键和值都可以是null
   WeakHashMap的键是“弱键”，也就是弱引用，是WeakReference类型的
   WeakReference和ReferenceQueue是联合使用的，如果弱引用所引用的对象被垃圾回收，java虚拟机就会把这个弱引用加入到与之关联的引用队列中，当下次对WeakHashMap进行操作时，会根据队列保存被GC的key删除WeakHashMap中对应的键值对




--------------------------------------------------------------------------------------------------- 
    
  3)LinkedHashMap

    按照插入顺序保存键，同时还保留了HashMap的查询速度


--------------------------------------------------------------------------------------------------- 
  4)TreeMap
   
  是一个有序的key-value集合，通过红黑树实现的。
  继承于AbstractMap，实现了NavigableMap接口，意味着支持一系列的导航方法，比如返回有序的key集合
  实现了Clonable接口 实现了java.io.Serializable接口。
  
  基于红黑树实现，该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的Comparator进行排序，具体取决于使用的构造方法
  
  TreeMap是非同步的，基本操作containsKey,get,put 和remove的时间复杂度是log(n)


  TreeSet 和 TreeMap在排序时如何比较元素？
  TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。
  TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序




--------------------------------------------------------------------------------------------------- 
   HashMap与Hashtable的区别

   1）继承不同
      HashMap 继承自AbstractMap  HashTable 继承自Dictionary

   2）HashTable中的方法是同步的，而HashMap中的方法在缺省的情况下是非同步的，在多线程并发的环境下，可以直接使用HashTable，使用HashMap时。要加同步处理

   3）HashTable中,key value都不允许出现null值，在HashMap中，null可以作为外键，这样的键只有一个，可以由一个或者多个键所对应的值为null。
      当get方法返回null值时，即可以表示HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不可以使用get方法判断是否存在某个键，而应该使用containsKey()来判断
  
   4）两个遍历方式的内部实现不同，HashTable和HashMap都使用了Iterator，HashTable还可以使用Enumeration的方式。

   5）哈希值的使用不同，HashTable直接使用对象的hashcode，而HashMap重新计算hash值，

   6）HashTable中的hash数组默认大小是11.增加方式是old*2+1
      HashMap中的hash数组默认大小为16 而且一定是2的指数

   7）在HashMap中的插入K/V对的过程中，总是插入后检查是否需要扩容，而HashTable则是先检查是否需要扩容后插入

--------------------------------------------------------------------------------------------------- 
   HashMap中数组的长度为什么是2的n次方？

   1）通过h & (table.length - 1)获得该对象在数组的位置（即桶的位置），2^n - 1得到的二进制的每个位上的值都是1，那么与全部为1的一个数进行与操作，速度会大大提升

   2) 当length总是2的n次方时，h & (table.length - 1)运算相当于对length取模，也就是h%length，但是&比%具有更高的效率

   3）当数组长度为2的n次幂时，不同的key算得的index相同的几率较小，那么数据在数组中的分布比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就提高了。


  HashMap中确定桶的位置使用的是h&(length-1)得到的，而h是通过key的hashcode值得到的，具体代码为：

   jdk1.7版本的
   static int hash(int h) {
        
        h ^= (h >>> 20) ^ (h >>> 12);
        return h ^ (h >>> 7) ^ (h >>> 4);
    }

   1.8版本 将四次右移变为一次

   static final int hash(Objcet key){

      int h;	
      return (key==null) ? 0 : (h = key.hashcode()) ^ (h >>>16);
   }


   key.hashcode()调用的是key的自带hash函数，返回int类型的返回值，理论上直接使用这个数是可以作为下标的，但是int类型值的范围为-2147483648到2147483648，范围太大，内存放不下，所以需要取模，这就解释了为什么数组的长度为2的n次方，因为length-1正好相当于一个“低位掩码”，“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问，这样一来，只取低位值，可能会有很严重的碰撞问题，这时，右移即为“扰动函数”向右移16位，正好为32位的一半，自己的高半区和低半区做异或，是为了混合原始哈希的高位和低位，以此来加大低位的随机性。

--------------------------------------------------------------------------------------------------- 


   HashTable不可以存储null的键和值，线程安全是通过synchronized实现的
   Properties类继承自HashTable 是线程安全的
   
   Hashtable遍历方式
   1）根据entrySet()获取Hashtable的“键值对"的Set集合，通过Iterator迭代器遍历得到的集合

   2）根据keySet()获取Hashtable的"键"的Set集合，通过Iterator迭代器遍历得到的集合
 
   3）根据values()获取的Hashtable的值的集合，通过Iterator迭代器遍历得到的集合

   4）根据keys()获取Hashtable的集合，通过Enumeration遍历得到的集合

   5）根据elements()获取Hashtable的集合，返回枚举类型 ，通过Enumeration遍历得到集合

   
   内部实现原理，源码，适用场景


--------------------------------------------------------------------------------------------------- 

3.并发包
  ConcurrentHashMap
  原理 源码 与hashmap的区别

  ConcurrentHashMap本质是一个segment数组，而每个segment实例又包含若干个桶，每个桶中都包含一条由若干个HashEntry对象链接起来的链表
  影响性能的三个重要参数：初始容量 负载因子 并发级别


 并发机制通过三方面保证：
  1）通过锁分段技术保证并发环境下的写操作
  2）通过HashEntry的不变性，Volatile变量的内存可见性和加锁重读机制保证高效，安全的读操作
  3）通过不加锁和加锁两种方案跨段操作的安全性


  与hashmap的区别：
  1）concurrenthashmap底层结构是一个segment数组 ，而不是Object数组

  2）在concurrenthashmap中，在HashEntry类中，key,hash和next域都被声明为final的（jdk1.6版本），在jdk1.7中，next域被volatile修饰，value域被volatile所修饰，因此HashEntry对象几乎是不可改变的，这是ConcurrentHashMap读操作不需要加锁的原因
     不加锁的三点原因：
     用hashentry对象的不变性来降低读操作对加锁的需求
     用volatile变量协调读写线程间的内存可见性
     若读时发生指令重排序现象，则加锁重读

  3）既不允许key值为null也不允许value值为null
 
  ConcurrentHashMap使用segment来分段和管理锁，segment继承自ReetrantLock,从而使得segment对象能充当锁的角色，因此 ConcurrentHashMap使用的是ReetrantLock来保证线程安全
  在默认理想状态下，ConcurrentHashMap可以支持16个线程执行并发写操作及任意线程的读操作
  
  在创建concurrenthashmap实例对象时，若没有指定concurrencyLevel（并发级别 即指定段数目） 默认值为16  


  ConcurrentHashMap的重哈希实际上是对ConcurrentHashMap某个段的重哈希，因此每个段包含的桶位不相同


  无论写线程对某个链表进行结构性修改还是非结构性修改，都不会影响其它的并发读线程对这个链表的访问

  在ConcurrentHashMap中，所有执行写操作的方法（put remove clear)在对链表做结构性修改后，在退出写方法前都会去写这个count变量
  所有未加锁的读操作（get contains containsKey）在读方法中，都会首先读取这个count变量

---------------------------------------------------------------------------------------------------  
  CopyOnWriteraArrayList(set)
  什么情况加锁，什么情况不加锁，适用场景

  即写时复制的容器，适用于读操作远多于修改操作的并发场景中，当我们往一个容器添加元素的时，不直接往当前容器添加，而是先将当前容器进行copy，复制出一个新的容器，然后往新的容器里添加元素，添加元素之后，再将原容器的引用指向新的容器。






---------------------------------------------------------------------------------------------------    
  ArrayblockingQueue(Linked)
  两者区别，take put offer poll 方法原理 源码
  
  Queue: 
   
  队列通常以FIFO的方式排序各个元素，不过优先级队列和LIFO队列例外，前者根据提供的比较器或元素自然顺序对元素排序，后者按LIFO的方式对元素进行排序，无论使用哪种排序方式，队列的头都是调用remove()或poll()所移除的元素

  offer方法可插入一个元素，否则返回false

  这与Collection.add方法不同，该方法只能通过抛出未经检查的异常（运行时异常）使添加元素失败，offer方法设计用于正常失败的情况，而不是出现异常的情况，例如在在容量固定（有界）的队列中

  remove()和poll()方法可移除和返回队列的头，在队列为空的时候，remove()方法抛出一个异常，而poll()方法返回null

  element()和peek()返回，但不移除队列的头

  Queue实现通常不允许插入null元素，尽管某些实现（如LinkedList）并不禁止插入null，即使在允许null的实现中，也不应该将null插入到Queue，因为null也用作poll方法的一个特殊的返回值，表明队列不包含元素


  BlockingQueue:

  支持两个附加操作的Queue，这两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用

  BlockingQueue方法以四种形式出现，对于不能立即满足但可能在将来某个时刻满足的操作，四种处理方式不同：

  1）抛出一个异常 add() remove() element()

  2) 返回一个特殊值（null或false）offer() poll() peek()
 
  3) 在操作可以成功前，无限期地阻塞当前线程 put() take()

  4) 在放弃前只在给定的最大时间限制内阻塞 offer(e, time, unit) poll(time, unit)


  BlockingQueue实现是线程安全的，所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的


  ArrayBlockingQueue:
 
  一个由数组支持的有界阻塞队列，此队列按FIFO原则对元素进行排序，此类支持对等待的生产者线程和使用者线程进行排序的可选公平策略，默认情况下时不公平的，然而，可以通过将公平性（fairness）设置true而构造的队列允许按照FIFO顺序访问线程，公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性（starvation 线程饿死）”


  ArrayBlockingQueue继承自AbstractQueue实现了BlockingQueue,Serializable接口

  类中使用一个 final Object[] items 数组存储元素

  类中有两个指针 
 
  takeIndex 指向下一个take,poll,peek or remove的元素的位置

  putIndex 指向下一个能put,offer or add元素的位置

  count 队列中元素的数量

  存取操作，都使用了ReentrantLock保证了线程安全

  add(e): 使用该方法添加一个元素时，如果没有超过队列的限制则返回true，若超过抛出异常

  offer(e): 使用该方法添加一个元素时，如果添加成功返回ture，失败返回false
 
  put(e): 使用该方法添加一个元素时，如果队列已满则会阻塞，没有返回值

  offer(e,timeout,unit): 使用该方法添加一个元素时，如果队列已满则等待给定的时间timeout


  poll(): 使用该方法取出一个元素时，如果队列为空返回null

  take(): 使用该方法取出一个元素时，如果队列为空则阻塞等待

  poll(timeout, unit): 使用该方法取出一个元素时，如果队列为空，则阻塞给定的时间timeout

  peek(): 返回队列头元素，但不取出



  LinkedBlockingQueue继承自AbstractQueue实现了BlockingQueue,Serializable接口

  一个基于已链接节点的，范围任意的blocking queue,此队列按FIFO排序元素

  链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低

  内部类Node<E> 有两个属性 E item, Node<E> next 

  LinkedBlockingQueue类中：
  
  int型常量capacity 代表队列的容量，当没有指定时为Integer.MAX_VALUE

  AtomicInteger型变量 count 代表队列此时的元素数量

  head last 头尾结点

  
  两个ReentrantLock锁，一个takeLock，取出锁，一个putLock 插入锁

  两个Condition notEmpty notFull

  
  方法：
  
  enqueue(node): 在队列尾插入元素

  dequeue(): 移除队列头元素  注意在移除元素时，将需要移除的元素的next指向自身 为了help GC，返回移除后新的首元素的值

 
  构造函数：
  
  当没有指定范围时，最大容量为Integer.MAX_VALUE，在创建队列是，会有一个为null的头结点

  

  添加：
  
  put(e): 使用该方法添加一个元素到队列尾，不允许添加为null的元素，否则抛出异常。在此方法内部中调用了enqueue方法。当队列满时，会阻塞。该方法没有返回值

  offer(e, timeout, unit): 使用该方法添加一个元素到队列尾，若队列已满，则阻塞指定时间timeout,如果添加成功返回true, 否则返回false

  offer(e): 使用该方法添加一个元素到队列尾，队列未满，添加成功返回true，否则返回false

  take() poll(timeout,unit) poll() 方法内部都调用了dequeue方法

  





































 

---------------------------------------------------------------------------------------------------   
  AtomicInteger(long boolean)
  功能
---------------------------------------------------------------------------------------------------    
  CountDownLatch
  功能 场景
  
  CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行 ex:应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行

  CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量，每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务

  计数器的值只能被设置一次，不可改变。

  使用场景：
  1) 实现最大的并行性
  2）开始执行前等待n个线程完成各自的任务
  3）死锁检测

  
---------------------------------------------------------------------------------------------------

  CyclicBarrier
  功能 场景

  一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点(common barrier point)，在设计一组固定大小的线程程序中，这些线程必须不时地互相等待，此时CyclicBarrier很有用

 与CountDownLatch不同： CountDownLatch是不能重用的，只能触发一次事件，场景：是等待其他线程完成后，某线程再开始工作
 而CyclicBarrier是可以重用的，场景：线程互相等待，到达同一屏障后，再同时执行

--------------------------------------------------------------------------------------------------- 
  
  FutureTask(Callable)
  源码 场景

  Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消、以及获取任务的结果和取消任务等。

  ExecutorService中所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的执行结果或者取消任务

  FutureTask实现了RunnableFuture接口，可将FutureTask提交给Executor执行  使用Sync进行同步控制

  可使用FutureTask包装Callable或Runnable对象



--------------------------------------------------------------------------------------------------- 
  
  ReentrantLock  是唯一实现了Lock接口的类
  与synchronized的区别，好处 场景

  可重入锁

  ReetrantLock实现了一种标准的互斥锁，每次最多只有一个线程能持有ReetrantLock。
  ReentarntLock和synchronized的区别：

    synchronized是java的关键字，是java的内置语言，是jvm层面同步的，ReetrantLock是java的一个类 是API层面的
    
    synchronized是可以自动释放锁的，ReentantLock必须手动释放锁

    通过lockinterruptibly()方法获取某个锁时，如果获取不到，进行等待，在等待的过程中是可以响应中断的，但通过synchronized获取锁时，无法获取就只能等待

    Lock可以知道有没有成功获取锁，而synchronized无法知道

    Lock可以提高多个线程的读操作效率

    


    在ReetrantLock的构造函数中提供了两种公平性选择：创建一个非公平的锁（默认）或者一个公平的锁。在公平的锁上，线程将按照他们发出请求的顺序来获得锁，但在非公平的锁上，则允许插队，当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。

    在公平的锁中，如果有另一个线程持有这个锁或者有其他线程在队列中等待这个锁，那么新发出请求的线程将被放入队列中。在非公平的锁中，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中

    在大多数情况下，非公平锁的性能要高于公平锁的性能
    当持有锁的时间相对较长，或者请求锁的平均时间间隔较长，那么应该使用公平锁。

   
    在一些内置锁无法满足需求的情况下，ReentrantLock可以做为一种高级工具。当需要一些高级功能使，才应该使用ReetrantLock,这些功能包括：可定时的，可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁，否则，还是应该优先使用Sychronized
   
    ReetrantLock的高级功能：等待可中断  可实现公平锁  锁可以绑定多个条件

    等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以放弃等待，改为处理其他事情

    绑定多个条件：指一个ReetrantLock对象可以同时绑定多个Condition对象

 
   AQS：队列同步器

     队列同步器（AbstractQueuedSynchronizer）是用来构建锁和其他同步组件的基础框架，技术是CAS自旋volatile变量：它使用了一个Volatile成员变量表示同步状态，通过CAS修改该变量的值，修改成功的线程表示获取到该锁，若没有修改成功，或者发现状态state已经是加锁状态，则通过一个Waiter对象封装线程，添加到等待队列中，并挂起等待被唤醒

    同步器实现锁的关键，子类通过继承同步器并实现它的抽象方法来管理同步状态，利用同步器实现锁的语义。特别地，锁是面向锁使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理，线程排队、等待与唤醒等底层操作。锁和同步器很好地隔离了锁的使用者与锁的实现者所需关注的领域



--------------------------------------------------------------------------------------------------- 
  Condition
  与wait nitify的区别 好处

  使用互斥并允许任务挂起的基本类是Condition，可以通过Condition上调用await（）来挂起一个任务，当外部条件变化时，意味着某个任务应该继续执行时，可以通过调用signal（）来通知这个任务，从而唤醒一个任务，或者调用signalAll()来唤醒所有在这个Condition上被其自身挂起的任务（与使用notifyAll()相比，signalAll()是更安全的方式）

  Condition更强大的地方在于:能够更加精细的控制多线程的休眠与唤醒

  ex：假如多线程读/写同一个缓冲区，当向缓冲区中写入数据之后，唤醒“读线程”，当从缓冲区读出数据之后，唤醒“写线程”

  如果采用Object类中wait() notify() notifyAll()实现该缓冲区，当向缓冲区写入数据之后，需要唤醒“读线程”时，不可能通过notify()或notifyAll()明确的指定唤醒“读线程”，而只能通过notifyAll()唤醒所有线程，但是通过Condtion，就能明确的指定唤醒“读线程”。
---------------------------------------------------------------------------------------------------   
  Semaphore
  好处 场景











--------------------------------------------------------------------------------------------------- 
  ReentrantReadWriteLock
  读写分离的好处 适用场景 源码

  ReadWriteLock 读写锁 ：一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行

  接口：
      public interface ReadWriteLock{
          Lock  readLock();
          Lock  writeLock();
      }

   要读取由ReadWriteLock保护的数据，必须首先获得读取锁，当需要修改数据时，必须获得写入锁。读取锁和写入锁只是读-写锁对象的不同视图

  ReentrantReadWriteLock 为这两种锁都提供了可重入的加锁语义


  当访问以读取操作为主的数据结构时，它能提高程序的可伸缩性

  
  与ReetrantLock类似，在构造时都提供了可重入的加锁语义，在公平锁中，等待时间最长的线程将优先获得锁。如果这个锁由读线程持有，而一个线程请求写入锁，那么其他读线程都不能获得读取锁，直到写线程使用完并释放了写入锁。 在非公平锁中，线程获得访问许可的顺序是不确定的，写线程降级为读线程是可以的，但是从读线程升级写线程则是不可的

  


--------------------------------------------------------------------------------------------------- 
  Executors
  线程池种类 各个作用 适用场景

  newFixedThreadPool  
    将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化（如果某个线程由于发生了未预期的Exception而结束，，那么线程池会补充一个新的线程）


  newCachedThreadPool
    将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制
 

  newSingleThreadExecutor
    是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建另一个线程来代替。newSingleThreadExecutor能确保依照任务在队列的顺序来串行执行（例如FIFO,LIFO,优先级）    
    单线程的Executor还提供了大量的内部同步机制，从而确保了任务执行地任何内存写入操作对后续任务来说都是可见的，这意味着，即使这个线程会不时地被另一个线程替代，但对象总是可以安全地封闭在“任务线程”中


  newScheduledThreadPool
    创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer     


  Executor执行的任务有4个生命周期：创建、提交、开始和完成  
 
--------------------------------------------------------------------------------------------------- 
 
 ThreadPoolExecutor
  重载方法的参数 各参数作用 源码

               ------ ExecutorService-------AbstractExecutorService------ThreadPoolExecutor
               |
  Executor-----|     
               |
               ------ ScheduledExecutorService-------ScheduledThreadPoolExecutor


 public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)


 corePoolSize: 池中所保存的线程数，包括空闲线程

 maximumPoolSize: 池中允许的最大线程数

 keepAliveTime: 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间

 uint：keepAliveTime参数的时间单位

 workQueue: 执行前用于保持任务的队列，此队列仅保持由execute方法提交的Runnable任务

 threadFactory：执行程序创建新线程时使用的工厂

 handler：由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序

 当新任务提交时，如果运行的线程少于corePoolSize，则创建新线程来处理请求，即使其他辅助线程时空闲的。
 如果运行的线程多余corePoolSize而少于maximumPoolSize,则仅当队列满时才创建新线程。如果池中当前有多于corePoolSize的线程，则这些多出的线程在空闲时间超过keepAliveTime时将会终止。这提供了当池处于非活动状态时减少资源消耗的方法。

 如果设置的corePoolSize和maximumPoolSize相同，则创建了固定大小的线程池。

 如果将maximumPoolSize设置为基本的无界值（如Integer.MAX_VALUE），则允许池适应任意数量的并发任务


 排队的三种策略：

  1.直接提交
    使用SynchronousQueue作为工作队列，它将任务直接提交给线程而不保持它们。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界maximumPoolSize以避免拒绝新提交的任务

  2.无界队列
    使用无界队列(ex:不具有预定义容量的LinkedBlockingQueue)将导致在所有corePoolSize线程都忙时新任务在队列中等待。这样创建的线程就不会超过corePoolSize。因此，maximumPoolSize的值也就无效了。
    当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列。

  3.有界队列
    当使用有限的maximumPoolSize时，有界队列（如：ArrayBloockingQueue），有助于防止资源耗尽，但是可能较难调整和控制，

    使用大型队列和小型池可以最大限度地降低CPU使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量


  四种拒绝策略：
  
  1）默认的AbortPolicy,处理程序遭到拒绝时将抛出运行时异常-RejectedExecutionException

  2) CallerRunsPolicy,直接在execute方法的调用线程中运行被拒绝的任务，如果执行程序已经关闭，则会丢弃该任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度

  3）DiscardPolicy 丢弃被拒绝的任务

  4）DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重行执行程序（如果再次失败，则重复此过程）



  
---------------------------------------------------------------------------------------------------  

4.虚拟机
  jvm五大区  每个区的存储 作用

   线程共享： java堆 方法区

   线程私有： 虚拟机栈  本地方法栈  程序计数器
--------------------------------------------------------------------------------------------------- 
   Method Area (方法区）：
    
      被虚拟机加载的类信息，静态变量，常量，即时编译器编译后的代码等数据， 运行常量池是方法区的一部分，class文件除了有 类的版本，字段 ，方法，接口，等描述信息外，还有一项信息常量池保存编译期生成的字面量和符号引用。

      运行时常量池具备动态性，在运行期也可能将新的常量放入池中，这种特性被开发人员利用得较多得是String类的intern()方法。


--------------------------------------------------------------------------------------------------- 
   Heap(堆）：

     在虚拟机启动时创建，唯一目的是存放对象的实例。

     java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象的分配在堆上也逐渐变得不是那么“绝对”了。


     java堆是垃圾收集器管理的主要区域，从内存回收的角度，现在收集器基本都采用分代收集算法，所以java堆中还可以细分为新生代和老年代。从内存分配的角度看，线程共享的java堆可能划分出多个线程私有的分配缓冲区（TLAB),不过无论怎么划分，都与存放的内容无关。

     java堆可以出于物理上不连续的内存空间中，只要逻辑上连续即可。




     在进行jvm调优时，关于堆的操作，java堆溢出，出现OutOfMemoryError异常，-Xmx 堆最大值 和 -Xms 堆最小值两个参数十分重要，出现异常时，分析时内存泄漏还是内存溢出。

    

---------------------------------------------------------------------------------------------------   
   VM Stack(虚拟栈）：

     描述的是java方法执行的内存模型，每个方法执行同时都会创建一个栈帧（Stack Frame)用于存储局部变量表，操作数栈，动态链表，方法出口等信息，每个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机中入栈到出栈的过程

    局部变量表存储的是编译期间可知的各种基本数据类型，对象引用和returnAddress类型，所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量的大小。

    异常： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常    如果扩展时无法申请到足够的内存，将会抛出OutOfMemoryError异常。
    

    在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。

    在建立多线程时会导致内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。
    
--------------------------------------------------------------------------------------------------- 
   Program Counter Register(程序计数器）：

    是当前线程所执行的字节码的行号指示器，若线程正在执行一个java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，若正在执行的是Native方法，计数器值为空。
    
    它是虚拟机规范中唯一一个没有规定任何OutOfMemoryError情况的区域。


--------------------------------------------------------------------------------------------------- 
   Native Method Stack(本地方法栈）：

      为虚拟机使用的Native方法服务


      在Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。

--------------------------------------------------------------------------------------------------- 


  jvm内存模型
  类加载机制

  从虚拟机的角度，只有两种不同的类加载器，一种是启动类加载器，使用c++实现，是虚拟机的一部分。 另一种加载器都由java语言实现，独立于虚拟机外部，全部继承自抽象类java.lang.ClassLoader
  
  绝大分java程序都会使用到三种类加载器：
  启动类加载器（Bootstrap ClassLoader) : 负责加载<JAVA_HOME>\lib 目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库， 加载虚拟机内存中，无法被java程序直接引用

  扩展类加载器（Extension ClassLoader) ：负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器

  应用程序类加载器（Application ClassLoader) : 也叫系统类加载器， 负责加载用户类路径(ClassPath)上所指定的类库，一般情况下没有自定义类加载器，这个就是默认的类加载器。

--------------------------------------------------------------------------------------------------- 
 
  类的生命周期包括：加载，验证，准备，解析，初始化，使用，卸载 7个阶段。 其中验证，准备，解析3个部分统称为连接。

  加载：1）通过一个类的全限定名来获取定义此类的二进制字节流
        2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
        3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口


  验证：确保Class文件中的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全


  准备：正式为类变量分配内存并设置类变量初始值的阶段，所使用的内存都将在方法区中进行分配， 进行分配时仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在实例化时随着对象一起分配在java堆中。但如果类变量被final修饰，那么在准备时直接赋好值。


  解析：是虚拟机将常量池内的符号引用替换为直接引用的过程


  初始化：在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其它资源。即初始化阶段是执行类构造器<clinit>()方法的过程
  <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。

  <clinit>()方法对于类或接口并不是必需的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。


--------------------------------------------------------------------------------------------------- 
  
  对于初始化阶段，虚拟机规范严格规定了有且只有5种情况必须立即对类进行初始化：
  1、遇到new  getstatic  putstatic 或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化，

     最常见的java代码场景是：使用new关键字实例化对象时，读取或者设置一个类的静态字段（被final修饰，已在编译期把结果放入常量池的静态字段除外）时，调用一个类的静态方法的时候

  2、使用反射对类进行调用时，若类没有初始化，则需要先触发其初始化。

  3、当初始化一个类，其父类还没有初始化，则需要先触发其父类的初始化

  4、当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个主类

  5，当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后解析结果REF_getStatic REF_putStatic REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。


  这5种场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。

  被动引用的例子：
  1、通过子类引用父类的静态字段，不会导致子类初始化。
  2、通过数组定义来引用类，不会触发此类的初始化
  3、常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化


  接口初始化：接口中不能使用static{}语句块，与类真正的区别是5种“有且仅有”的第三种，一个接口在初始化时，并不要求其父类接口全部都完成初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

  
  装载类时，编译器会找到其.class文件，然后将该类的字节码文件装入内存，此时共两种方案可供选择： 第一种，让即时编译器编译所有的代码，缺陷：加载动作散落在整个程序生命周期内，时间花费长，增加可执行代码的长度，导致页面调度，降低程序速度
   第二种，惰性编译，即时编译器只在必要的时候才会编译代码，Hotspot技术采取了类似方法，每次执行的时候，做优化，执行次数越多，速度越快
 
--------------------------------------------------------------------------------------------------- 
 双亲委派模型

    类加载器之间的层次关系，称为类加载器的双亲委派模型， 除了顶层的启动类加载器之外，其余的类加载器都应当有自己的父类加载器。父子关系不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码


  
 工作过程：收到类加载的请求，把请求先委派给父类加载器完成，因此所有的请求都会传送到顶层的启动类加载器中，只有父加载器无法完成加载请求，子加载器才会加载。

 好处：java类随类加载器一起具备了一种带有优先级的层次关系，

 实现双亲委派的代码都集中 在 java.lang.ClassLoader的loadClass()方法中，加载逻辑：
     先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空，则默认使用启动类加载器做为父加载器，如果父类加载失败，抛出ClassNotFoundException异常后，调用自己的findClass()方法进行加载
---------------------------------------------------------------------------------------------------   
---------------------------------------------------------------------------------------------------   
  垃圾收集器

  常用gc算法
   
   1)标记-清除算法 ： 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象   
     不足：效率不高  标记清除后会产生大量的不连续的内存碎片


   2）复制算法 ：将可用的内存按容量分为大小相等的两块，每次只使用一块，当这块使用完后，将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉
      实现简单，运行高效，代价是将内存缩小为原来的一半
   
      现在的商业虚拟机都采用这种收集算法来	Eden和刚才用过的Survivor空间，如果令一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代


   3）标记-整理算法： 标记过程仍然与标记-清除一样，但后续步骤不是直接对可回收对象及进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉段边界以外的内存
      用于回收老年代

   4）分代收集算法：把java对象分为新生代和老年代  新生代用复制算法  老年代用标记-清理 或者 标记-整理算法


  收集器种类 适用场景
 
    1）Serial收集器
       单线程收集器，在它进行垃圾收集时，必须暂停其它所有的工作线程，直到它收集结束， 它依然是虚拟机运行在Client模式下的默认新生代收集器


    2）ParNew收集器
       Serial收集器的多线程版本  是许多运行在Server模式下的虚拟机中首选的新生代收集器  目前只有它能与CMS(Concurrent Mark Sweep)收集器配合工作


    3）Parallel Scavenge收集器  也称“吞吐量优先”收集器
       是一个新生代收集器，使用复制算法的收集器，又是并行的多线程收集器，此收集器的特点是与其它收集器的关注点不同，CMS收集器的关注点是尽可能的缩短垃圾收集时用户线程的停顿时间，而此收集器的目标则是达到一个可控制的吞吐量
       此收集器有GC自适应调节策略：虚拟机根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或者最大的吞吐量，自适应调节策略也是Parallel Scavenge收集器和ParNew收集器的一个重要区别

    4）Serial Old收集器
       是Serial收集器的老年代的版本，同样是一个单线程收集器，使用标记-整理算法 

    5）Parallel Old 收集器
       是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法 一般配对使用


    6）CMS收集器 Concurrent Mark Sweep
       是一种以获取最短回收停顿时间为目标的收集器  基于标记-清除算法   整个过程分为4个步骤：初始标记  并发标记   重新标记  并发清除
       优点：并发收集 低停顿

       缺点：对CPU资源敏感    无法处理浮动垃圾，可能出现“Concurrent Model Failure”失败而导致另一次Full GC 的产生，会产生大量的空间碎片
     
       回收的只是Old区或者Perm区的垃圾对象，与Minor GC 和 Full GC 基本没有关系
   

    7）G1 收集器 Garbage-First 是面向服务端应用的垃圾收集器
       特点：并行和并发  分代收集  空间整合  可预测的停顿

       G1收集器将java堆划分为多个大小相等的独立区域Region，虽然还保留有新生代和老生代的概念，但新生代和老年代不再是物理隔离的，它们都是一部分Region（不需要连续）的集合

       回收策略：G1跟踪各个Region里面的垃圾堆的价值大小（回收所获得的空间以及优先级的区域回收方式），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，这种使用Region划分内存空间以及优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

       在G1收集器中，虚拟机使用Remembered Set来避免全堆扫描  



  
  Parallel GC 根据Minor GC 和 Full GC的不同分为三种，分别是ParNewGC,ParallelGC和ParallelOldGC

  ParrllelGC 和 ParrallelOldGC 的不同 ：体现在Full GC上，前者Full GC进行的动作为清空整个Heap堆中的垃圾对象，清除Perm区中已经被卸载的类信息，并进行压缩。而后者是清除Heap堆中的部分垃圾对象，并进行部分的空间压缩







---------------------------------------------------------------------------------------------------      
  FullGC MinorGC触发条件
  
  MinorGC 指发生在新生代的垃圾收集动作
  FullGC 指发生在老年代的GC
  
  MinorGC 触发条件： 对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC

 
  大对象直接进入老年代，大对象指的是需要大量连续内存空间的java对象，最典型的大对象就是那种很长的字符串以及数组。

  空间分配担保：

  在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代的所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailur设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC,尽管这次有风险，如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC.
  

  当Minor GC时，除了将Eden区的非活动对象回收以外，还会把一些对象也复制到Old区中，老对象的定义可以通过配置参数MaxTenuringThreshold来控制,或者MinorGC时，survivor区中的To Space放不下这些对象时，这些对象也将直接放入Old区

  如果Old区或者Perm区空间不足，将会触发Full GC,Full GC会检查Heap堆中的所有对象，清除所有垃圾对象，如果是Perm区，会清除已经被卸载的classloader中加载的类的信息
   

  FullGC触发条件：
  1）调用System.GC()方法
 
  2）老年代空间不足

  3）永久代空间不足

  4）GC担保失败


---------------------------------------------------------------------------------------------------    
  jvm优化
  可视化工具使用 
  日志查询
  各项参数设置
  四种引用

  
  JDK的命令行工具

  jps: JVM Process Status Tool 虚拟机进程状况工具

  可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称及这些进程的本地虚拟机唯一ID 

  jstat: JVM Statistics Monitoring Tool 虚拟机统计信息监视工具

  是用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台的环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具


  jinfo：Configuration Info for Java java配置信息工具

  作用是实时地查看和调整虚拟机各项参数

  jmap：Memory Map for Java java内存映像工具
 
  用于生成堆转储快照（heapdump或dump文件）

  
  jhat：JVM Heap Analysis Tool虚拟机堆转储快照分析工具

  与jmap搭配使用，来分析jmap生成的堆转储快照，jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。

  jstack:Stack Trace for java java堆栈跟踪工具

  用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件），线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因       
  

  JDK的可视化工具

   JConsole和VisualVM 

   JConsole是一种基于JMX的可视化监视、管理工具

   VisualVM:多合一故障处理工具（All-in-One Java Troubleshooting Tool）,是JDK发布的功能最强大的运行监视和故障处理程序








   java的引用概念：
   
    强引用（Strong Reference):类似Object obj=new Object();这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

    软引用（Soft Reference):描述一些还有用但并非必须的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围进行第二次回收。

    弱引用（Weak Reference): 描述非必须对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

    虚引用（Phantom Reference):一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。



---------------------------------------------------------------------------------------------------   

5.IO流
  BIO
  字节流：类型 适用场景
  字符流：类型 适用场景

  BIO 即阻塞IO，在基于Socket的消息通信过程中，Socket服务端向外部提供服务，而Socket客户端可以建立到Socket服务端的连接，进而发送请求数据，然后等待Socket服务端处理，并返回处理结果（响应）

  基于BIO的通信，Socket服务端会发生阻塞，即在监听的过程中每次accept到一个客户端的Socket连接，就要处理这个请求，而此时其他连接过来的客户端只能阻塞等待，在这种模式下Socket服务端的处理能力十分有限。
---------------------------------------------------------------------------------------------------  
  NIO
  类型 适用场景
  三大组件的联系 使用
  内存情况

  三大组件
***************************************************************************************************   
  通道（Channel）
    既可以在通道中读取数据，又可以写数据到通道；通道可以异步地读写；通道中的数据总是先要读到一个buffer（缓冲区），或者从一个buffer中写入
     Channel的实现：FileChannel 从文件中读写数据   DatagramChannel 能通过UDP读写网络中的数据  SocketChannel 能通过TCP读写网络中的数据   ServerSocketChannel可以监听新进来的TCP连接，像web服务器那样。对每一个新进来的连接都会创建一个SocketChannel

***************************************************************************************************

  缓冲区（Buffer）用于和NIO通道进行交互   本质上是一个可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存

  基本用法： 读写数据一般遵循以下四个步骤：
  1.写入数据到Buffer  2.调用flip()方法  3.从buffer中读取数据  4.调用clear()方法或者compact()方法

  flip()方法 将Buffer从写模式切换到读模式  会将position设回0，并将limit设置成之前position的值
  读完数据后，需要清空缓冲区  clear()方法 清空整个缓冲区  compact()方法只会清除已经读过的数据，任何未读的数据都被移到缓冲区的起始处，新写入的数据将防盗缓冲区未读数据的后面

   三个属性：
    capacity：作为内存块，buffer有一个固定的大小值。一旦buffer满了，需要将其清空才能继续写数据

    position：写数据时，position表示当前位置，初始的position值为0，最大可为capacity-1
              读数据时，position会被重置为0，当从buffer的position处读取数据时，position向前移动到下一个可读的位置

    limit：在写模式下，limit表示最多能往buffer中写多少数据。写模式下，limit等于capacity
           读模式，limit表示最多能读到多少数据，此时，limit会被设置成写模式下的position值
  
    可以通过char short int long float或double类型来操作缓冲区中的字节

    flip()方法
  
    rewind()方法  将position设回0，所以可以重读buffer中的所有数据，limit保持不变

***************************************************************************************************
  Scatter和Gather   用于描述从Channel中读取或者写入到Channel中操作

    分散（Scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中
  
      Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用与动态消息（消息大小不固定）。如果存在消息头和消息体，消息头必须完成填充，Scattering Reads才能正常工作

    聚集（Gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel

      Gathering Writer，将数据写入到Channel中，只有position到limit之间的数据才会被写入，与Scattering Reads相反，能较好的处理动态消息
***************************************************************************************************

  通道之间的数据传输

  如果两个通道中有一个是FileChannel,那个可以直接将数据从一个Channel传输到另外一个Channel

  transferFrom()
  FileChannel 的 transferFrom()方法可以将数据从源通道传输到FileChannel中

  toChannel.transferFrom(position,count,fromChannel);  fromChannel源通道  toChannel（FileChannel）

  在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节），因此，SocketChannel可能不会将所请求的所有数据（count个字节）全部传输到FileChannel


  transferTo()
  将数据从FileChannel传输大其他的channel中

  fromChannel.transferTo(position,count,toChannel);   fromChannel(FileChannel) toChannel(其他channel）

***************************************************************************************************

  Selector（选择器） 是 NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件，这样，一个单线程就可管理多个Channel，从而管理多个网络连接

  向Selector注册通道
   为了将Channel和Selector配合使用，必须将Channel注册到selector上，通过SelectableChannel.register()方法来实现

       channel.configureBlocking(false);
       SelectinonKey key = channel.register(selector, SelectionKey.OP_READ);

    与Selector一起使用时，Channel必须处于非阻塞模式下，这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字通道可以

    register()方法的第二个参数 ，这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣，可以监听四种不同的类型事件

   Connect   Accept  Read  Write

   通道出发了一个事件意思是改时间已经就绪

   事件的常量表示方法  SelectionKey.OP_XXXX   不止一件 可以使用“位或”操作符将常量连接起来

   常用方法
   通过Selector选择通道
   
     调用几个重载的select()方法，返回所感兴趣的事件已经准备就绪的通道 

     int select()   阻塞到至少有一个通道在你注册的事件上就绪了  
     int select(long timeout)   
     int selectNow() 不会阻塞 没有通道可选择 返回0
     返回int值表示有多少通道已经就绪，即 自上次调用select()方法后有多少通道变成就绪状态

   selectedKeys()
   通过调用此方法，访问“已选择键集（selected key set）”中的就绪通道


   close()  用完Selector后关闭，且使注册到该Selector上所有SelectorKey示例无效，通道不身并不会关闭

***************************************************************************************************

 FileChannel  
  是一个连接到文件的通道，可以通过文件通道读写文件，无法设置为非阻塞模式，总是运行在阻塞模式下

  打开FileChannel，需要通过一个InputStream , OutputStream 或 RandomAccessFile来获取一个FileChannel实例

  从FileChannel读取数据  先分配一个buffer，调用read方法，buffer作为参数，返回的int值表示有多少字节被读到了buffer中，如果返回-1，表示到了文件末尾

  向FileChannel写数据，调用writer方法，buffer作为参数，

    while(buf.hasRemaining()){
        channel.write(buf);
    } 
    在while循环中使用，因为无法保证write方法一次能向FileChannel写入多少字节，因此需要重复调用write方法，直到buffer中已经没有尚未写入通道的字节

   truncate方法   截取一个文件，文件将指定长度后面的部分删除

   force方法  将通道里面尚未写入磁盘的数据强制写到磁盘上，由于性能方法的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上

   方法中有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上

***************************************************************************************************

  SocketChannel

  打开SockeChannel的两种方式：
  1.打开一个SocketChannel并连接到互联网上的某台服务器
  
  2.一个新连接到达ServerSocketChannel时，会创建一个SocketChannel

---------------------------------------------------------------------------------------------------   

6.大数据
  zookeeper
  kafka  
  redis集群
  storm
  hadoop
  spark
  solr cloud
  挑一两个组件深入理解下就好


---------------------------------------------------------------------------------------------------   

7.数据库
  三范式
  主从复制   原理  实现



 
  读写分离
   
   使用中间件（mysql_proxy，amoeba等）实现读写分离

   my_proxy可以实现负载均衡和读写分离 proxy的端口为4040

   负载均衡：体现在连接上，而不是sql语句上，mysql_proxy会把连接mysql服务器的TCP/IP连接缓存进连接池以提高性能，在缓存池中，缓存的连接大致是平均分配在每台mysql服务器上

   读写分离：利用mysql_proxy自带脚本做出读写判断
  原理 实现
  
  事务
    类型
    使用
    可能引起的问题

   PreparedStatement 继承自Statement PreparedStatement实例包含已编译的SQL语句，所以其执行速度快于Statement、
   Statement 是不传入参数的，PreparedStatement是要传入sql语句的，通过PreparedStatement可以防止sql注入，安全性高。


---------------------------------------------------------------------------------------------------   


  存储引擎
   innoDB
   MyISAM
   区别 联系 锁机制 适用场景
     
---------------------------------------------------------------------------------------------------      
  索引
   类型
   使用
   什么样的字段适合做索引


   类型

   B-Tree  

   特点：
   
   全值匹配  左前缀  范围匹配  聚簇索引


   Hash

   特点:
    
   理论寻址O(1)  必须回行  无法排序优化   不能前缀索引   不适宜范围查询


   两者的区别

   （1）Hash 索引仅仅能满足"=","IN"和"!="查询，不能使用范围查询。 
       
        由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。 
   
   （2）Hash 索引无法被用来避免数据的排序操作。 

        由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算； 

   （3）Hash 索引不能利用部分索引键查询。 

        对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。 

   （4）Hash 索引在任何时候都不能避免表扫描。 
        
        Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。 

   （5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 
     
        对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。

 
   FULLTEXT： 全文索引

 

   RTREE












  唯一索引 ：在表上一个或者多个字段组合建立的索引，这些字段的值组合起来在表中不可以重复

  非唯一索引：在表上一个或者多个字段组合建立的索引，这些字段的值组合起来在表中可以重复，不要求唯一

  主键索引：是唯一索引的特定类型，表中创建主键时自动创建的索引，一个表只能建立一个主索引
 
  聚簇索引（聚集索引）：表中记录的物理顺序与键值的索引顺序相同，一个表只能有一个聚集索引

  聚簇索引和非聚簇索引的区别：是表中记录的物理顺序和索引的排列顺序是否一致 ，聚簇索引的表中记录的物理顺序与索引的排列顺序一致

  聚簇索引的场合：某列包含了小数目的不同值     排序和范围查找

  非聚簇索引的场合：此列包含了大数目的不同值    频繁更新的列

  组合索引：基于多个字段而创建的索引











---------------------------------------------------------------------------------------------------    
 
8.SQL优化



--------------------------------------------------------------------------------------------------- 
  web
  Tomcat
  结构 流程 源码

  Tomcat的两大核心组件：Connector 和 Container

  Connector组件的主要任务时负责接收浏览器发过来的TCP连接请求，创建一个Request和Response对象分别用于和请求端交换数据，然后会产生一个线程来处理这个请求并把产生的Request和Response对象传给处理这个请求的线程，处理这个请求的线程就是Container组件要做的事


  处理流程：
  1） 请求到达HttpConnector，Connector调用initialize()方法，初始化一个ServerSocket

  2)  初始化一个线程，等待新的连接请求

  3） 创建一定大小的线程池，构建request，response对象

  4） 所有的线程进行入await()

  5)  请求到来，将socket分配给HttpPorcessor

  6） 激活线程，开始run()方法执行

  7） 创建SocketInputStream为input，output对象 这里还包括解析HTTP协议，将Header都组装到request和response对象中，以便将这两个对象传给Container组件使能够有足够的连接信息

  8） 将request和response对象那个传给Container组件执行

  9） 一次Servlet处理

 10） 返回request和response对象
  
 11） output.flush()将结构返回给客户端

 12) request、response对象生命周期结束，关闭当前socket

  
  Container组件，是容器的父接口，所有的子容器都必须实现这个接口，Container容器的设计用的是典型的责任链的设计模式，它由4个子容器组件构成，分别是Engine、Host、Context和Wrapper，这4个组件不是平行的，而是父子关系，Engine包含Host，Host包含Context，Context包含Wrapper，通常一个Servlet class对应一个Wrapper，如果有多个Servlet，则可以定义多个Wrapper。如果有多个Wrapper，则要定义一个更高的Container


  Host容器不是必需的，但是要运行war程序，就必须要用Host，因为war中必有 web.xml文件，这个文件的解析就需要Host，如果有要有多个Host就要定义一个top容器Engine，而Engine没有父容器，一个Engine代表一个完整的Servlet引擎

  Host是Engine的子容器，一个Host在Engine中代表一个虚拟主机，这个虚拟主机的左右就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分他们，它的子容器通常是Context，它除了关联子容器外，还保存一个主机应有的信息


  Context容器，代表Servlet的Context，它具备了Servlet运行的基本环境，理论上只要有Context就能运行Servlet，简单的Tomcat可以没有Engine和Host。它最重要的功能就是管理它里面的Servlet实例，Servlet实例在Context中是以Wrapper出现的。


  Context的配置文件中有有个reloadable属性，设为true是，war被修改后Tomcat会自动重新加载这个应用

  

  Wrapper容器
  Wrapper代表一个Servlet，它负责管理一个Servlet，包括Servlet的装载，初始化，执行及资源回收，Wrapper是最底层的容器，它没有子容器。

  实现类是StandardWrapper，此类还实现了拥有一个Servlet初始化信息的ServletConfig

  调用LoadServlet方法装载Servlet，装载后就会调用Servlet的init方法，同时会传给一个StandradWrapperFacade对象给Servlet，这个对象包装了StandardWrapper,Servlet可以获得的信息在StandardWrapperFacade里封装，这些信息又是在StandardWrapper对象中拿到的，所以Servlet可以通过ServletConfig拿到有限的容器的信息，完成初始化后，等着StandardWrapperValve去调用它的Service方法




---------------------------------------------------------------------------------------------------    
  Servlet
  
  Servlet是一种组件（component）,由Servelt Container(容器）进行管理，管理方式：创建Servlet，初始化信息，管理Servlet对请求的服务处理，销毁Servlet对象


  生命周期
  分为三个阶段
  1）初始化阶段 调用init()方法
  2）相应客户请求阶段 调用service()方法
  3）终止阶段 调用destory()方法，不一定被垃圾回收，一般处理是钝化

  三种实现方式
  1）实现servlet接口，servlet接口中定义了五个方法，比较重要的三个方法涉及的servlet的生命周期
  2）继承GenericServlet, GenericServlet是一个通用的，不特定于任何协议的Servlet，它实现了Servlet接口
  3）继承HttpServlet,在HttpServlet有service方法，在方法内部将servlet中的request和response强制转换为httprequest 和 httpresponse 

   

  在默认情况下，容器只会为每个servlet类创建唯一的一个实例（单例模式），当有多个请求到达容器，就有可能有多个线程同时访问同一个实例

  Servlet是什么时候创建的？

  A.Tomcat服务器启动的时候   B. 第一次访问的时候


  Servlet的构造函数与init()的区别？ 

  在构造函数的时候，ServletConfig对象是null。  在构造函数中，不能抛异常，不能做复杂的初始化操作。所有的参数信息，要在init()中读取


  并发环境的线程安全问题：
  解决方式：
   1）加锁 通常使用代码块加锁

   2）让servlet实现SingleThreadModle接口（不建议使用）
       容器会为实现该接口的servlet创建多个实例，即一个线程分配一个，这种方式创建了过多的servlet实例，系统开销太多，不建议使用

   3）servlet的属性尽量设置成只读的，不要去修改




 什么是Servlet？

 所有实现了 javax.servlet  Interface Servlet 的 Class,都可以称为Servlet

  servlet的层级结构和常用类：

   GenericServlet类：抽象类，定义了一个通用的、独立于底层协议的Servlet

   大多数Servlet通过从GenericServlet或HttpServlet类进行扩展来实现

   ServletConfig接口定义了在Servlet初始化的过程中有Servlet容器传递给Servlet的配置信息对象，通过ServletConfig,读取Servlet的初始化参数信息

   void init(Servlet config)
  

   HttpServletRequest接口扩展ServletRequest接口，为HttpServlet提供HTTP请求信息

  

  ex：第一次访问Servetl对象时，Servlet的处理阶段是：
      1. LoginSvl构造函数
  
      2. init函数

      3. service方法

      4. doGet函数

      5. destory方法    


  重定向（redirect)和转发（dispatch）的区别？

  request.getRequestDispatcher("/error.jsp").forward(request, response);

  response.sendRedirect( basePath + "MainSvl");

  1）转发是客户端发出了一次请求，在服务器内部进行跳转，客户端显示的地址不变。重定向是客户端发出两次请求。地址发生变化
 
  2）转发的好处是，一次请求速度快

  3）重定向的好处是，地址栏只记录最后一次提交（可以防止二次提交），重要的操作，如付费提交，一定要使用重定向

  4）重定向可以访问网站的外部资源，转发只能在服务器内部资源转发
 


--------------------------------------------------------------------------------------------------- 
   
  springMVC

  初始化

  DispathcerServlet类继承了HttpServlet，在Servlet的init方法调用时DispatcherServlet执行Spring MVC的初始化工作，在其initStrategies方法中初始化8个组件

  HttpServlet初始化调用了HttpServletBean的init方法，该方法的作用是获取Srevlet中的init参数，并创建了一个BeanWrapper对象，然后由子类处真正执行BeanWrapper的初始化工作。但是HttpServletBean的子类FrameworkServlet和DispatcherServlet都没有覆盖其initBeanWrapper(bw)方法，所以创建的BeanWrapper对象没有任何作用，Spring容器也不是通过BeanWrapper来创建的

  Spring容器的创建是在FrameworkServlet的initServletBean()方法中完成的，这个方法创建了WebApplicationContext对象，并调用其refresh()方法来完成配置文件的加载。 Spring容器在加载时会调用DispatcherServlet的initStrategies方法来完成DispatcherServlet中定义的初始化工作

  使用

  整个Spring MVC的调用是从DispatcherServlet的doService方法开始的，在doService方法中会将ApplicationContext,localResolver,themeResolver等对象添加到request中以方便在后面使用，接着就是调用doDispatch方法，这个方法是主要的处理用户请求的地方

  Control的处理逻辑关键就是在DispatherServlet的handlerMappings集合中根据请求的URL匹配每个HandlerMapping对象中的某个Handler,匹配成功后将会返回这个Handler的处理链HandlerExecutionChain对象，而在这个HandlerExecutionChain对象中将会包含用户自定义的多个HandlerInterceptor对象

  

  请求流程 :

  1) 浏览器发出请求，前端控制器DispatcherServlet接受用户请求，响应

  2）DispatcherServlet到处理器映射器HandlerMapping请求查找Handler，映射器返回一个执行链HandlerExecutionChain（包括HandlerInterceptor和Handler）到DispatcherServlet，通过调用HandlerExecutionChain的getHandler方法返回Handler，但是返回的是Object对象，所以在这里Handler对象是没有类型的，Handler的类型由HandlerAdapter决定的，DispatcherServlet会根据Handler对象在其handlerAdapters集合中匹配哪个HandlerAdapter实例来支持该Handler对象，接下来执行Handlerd对象的相应方法

  3）DispatcherServlet请求适配器HandlerAdapter执行Handler,返回ModelAndView
     HadlerAdapter的初始化，创建一个HandlerAdapter对象，将这个对象保存在DispatcherServlet的handlerAdapters集合中，当Spring MVC将某个URL
对应到某个Handler时，在handlerAdapters集合中查询那个handlerAdapter对象supports这个Handler，handlerAdapter对象将会被返回，并调用这个handlerAdapter接口对应的方法。

     HandlerAdapter实现类：

       HttpRequestHandlerAdapter:继承HttpRequestHandler接口，实现void handlerRequest(request,response)方法，没有返回值

       SimpleControllerHandlerAdapter:继承Controller接口，实现public ModlerAndView handler(request,response,Object handler)方法，返回ModlerAndView对象，用于后续的模板渲染

       SimpleServletHandlerAdapter:继承Servlet接口，将一个Servlet作为一个Handler来处理这个请求

 
     ModelAndView对象是连接业务逻辑层与View展现层的桥梁，也是连接Handler与View的桥梁，该对象会持有一个ModelMap对象和一个View对象或者View的名称。ModelMap对象就是执行模板渲染时所需要的变量对应的实例。ModelMap其实也是个Map,在Handler中将模板中需要的对象存在这个Map中，然后传递到View对应的ViewResolvers中，不同的ViewResolvers会对这个Map中的对象有不同的处理方式
    
     

  4）DispatcherServlet请求视图解析器ViewResovler进行视图解析，返回view对象
  
      View模块由两个组件支持，分别是RequestToViewNameTranslator和ViewResolver。RequestToViewNameTranslator支持用户自定义对ViewName的解析，如将请求的ViewName加上前缀或者后缀，或者替换成特定的字符串

      ViewResolver用于根据用户请求的ViewName创建合适的模板引擎来渲染最终的页面，会根据ViewName创建一个View对象，调用View对象的void render(model,request,response)方法渲染页面。

      Jsp的ViewResolver对应的是InternalResourceViewResolver类，当调用resolveViewName方法时会调用createView方法，将ViewClass属性对应的InternalResourceView类实例化，最后调用InternalResourceView的render发法渲染JSP页面


  5）前端控制器进行视图渲染，将模型数据（在ModelAndView对象中）填充到request域

  6）前端控制器向用户响应结果



   SpringMVC中的设计模式：
     1）模板模式   应用：由抽象父类定义主体执行流程，而由子类去实现这个流程中的单个步骤的模式

         HandlerMapping的设计 View的设计




   SpringMVC和Struts2的区别：

    1.SpringMVC是基于方法开发的，struts2基于类开发的

      SpringMVC将URL和Controller方法映射，映射成功后SpringMVC生成一个Handler对象，对象中只包括了一个method，方法执行结束，形参数据销毁

      SpringMVC的Controller开发类似Service开发

    2.SpringMVC可以进行单例开发，并且建议使用单例开发，Struts2通过类的成员变量接受参数，无法使用单例，只能是多例

    3.经过实际测试，Struts2速度慢，在于使用struts标签，如果使用Struts建议使用jstl

---------------------------------------------------------------------------------------------------   
  spring
  IOC/AOP原理 源码 联系
  两种动态代理实现

  Spring的核心组件：Core Context Bean

  Bean包装的是Object，在Spring中的作用就像Object对OOP的意义一样

  Context发现每个Bean之间的关系，为它们建立这种关系并且维护好这种关系，所以Context就是一个Bean关系的集合，这个关系集合又叫IOC容器

  Core就是发现、建立和维护每个Bean之间的关系所需要的一系列工具


  Bean组件：
    Spring Bean的创建是典型的工厂模式，顶级接口是BeanFactory,他有3个子类：ListableBeanFactory（Bean可列表）,HierarchicalBeanFactory（Bean有继承关系）,AutowireCapableBeanFactory（定义Bean的自动装配规则）。 
    
    最终的默认实现类是DefaultListableBeanFactory,它实现了所有的接口，接口主要是为了区分在Spring内部对象的传递和转化过程中，对对象的数据访问所做的限制。

    当Spring成功解析定义的一个<bean/>节点后，在Spring的内部就被转化成BeanDefinition对象，以后所有的操作都是对这个对象进行的


  Context组件：
    给Spring提供一个运行时的环境，用以保存各个对象的状态

    ApplicationContext是Context的顶级父类，它除了能标识一个应用环境的基本信息外，还继承了5个接口，扩展Context的功能

    ApplicationContext继承了BeanFactory，说明了Spring容器运行的主体对象是Bean,还继承了ResourceLoader接口，使得ApplicationContext可以访问到任何外部资源

    ApplicationContext 必须完成的：
     1）标识一个应用环境
     2）利用BeanFactory创建Bean对象
     3）保存对象关系表
     4）能够捕获各种事件

   

  Core组件：
    重要组成部分就是定义了资源的访问方式

    Resource接口继承了InputStreamSource接口， 在这个接口中有个getInputStream方法，返回的是InputStream类，这样所有的资源都可以通过InputStream类来获取，屏蔽了资源的提供者。资源的加载由ResourceLoadar接口完成，屏蔽了所有的资源加载者的差异，只需要实现这个接口皆可以加载所有的资源，默认实现是DefaultResourceLoader

   Context把资源的加载、解析和描述工作委托给了ResourcePatternResolver类来完成


  AOP的源码中用到了两种动态代理来实现拦截切入功能：JDK动态代理和CGLIB动态代理 
 
    JDK动态代理是由java内部的反射机制来实现的，CGLB动态代理底层则是借助asm来实现的

    发射机制在生成类的过程的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效。

    jdk动态代理的局限性：必须是目标类基于同一的接口

    JDK动态代理：
     1）反射 proxy类：类的静态方法用来生成动态代理的实例
        static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) 
  	loader ： 定义代理类的类加载器
        interface ：代理类要实现的接口列表
        h : 指派方法调用的调用处理程序

     2）innovationhandler 接口有一个invoke方法，用来几种处理在动态代理类对象的方法调用，通常在该方法中实现对委托类的代理访问，每次生成动态代理对象时都要指定一个对应的调用处理器

       Object invoke(Object proxy, Method method, Object[] args)  
       proxy : 在其上调用方法的代理实例
       method : 对应于在代理实例上调用的接口方法的Method实例，Mehtod对象的声明类将是在其中声明方法的接口，该接口可以是代理类赖以继承方法的代理接口的超接口
       args : 包含传入dialing实例上方法调用的参数值的对象数组，如果接口方法不使用参数，则为null。基本类型的参数被包装在适当基本包装器类（如java.lang.Integer或java.lang.Boolean）的实例中



     CGLB动态代理：针对类来实现代理，原理是对指定的目标类生成一个子类，并且覆盖其中的方法实现增强，因为采用的是继承，所以不能对final修饰的类进行代理
   
     核心类：
       net.sf.cglib.proxy.Enhance  主要增强类
       net.sf.cglib.proxy.MethodInterceptor  主要的方法拦截类，它是Callback接口的子接口，需要用户实现
       net.sf.cglib.proxy.MethodProxy  JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用

     创建增强类：
       Enhancer enhancer = new Enhancer();
       enhancer.setSuperclass(需要增强类的class对象);
       enhancer.setCallback(代理类对象);

     创建代理类：
       public class CglibProxy implements MethodInterceptor
       重写 public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy）方法
    

  Spring中设计模式的使用：

   1）代理模式 AOP中JDK动态代理
   2）策略模式 Bean定义对象的创建及代理对象的创建等



  Spring中bean的实例化过程：  bean的实例化是在BeanFactory中发生的 PreInstantiateSingletons方法
  
   1）循环获取beanDefinitionNames中beanName

   2）在获取bena的定义的RootBeanDefinition对象

   3）调用getBean方法
   
   4）判断是否可以实例化（是单例对象，不是抽象类，不是LazyInit）

   5) 判断是否是FactoryBean 是 获取FactoryBean对象本身

   6）不是FactoryBean，再查询singletonObjects缓存对象中是否已存在对象

   7）检查是否有父工厂对象存在，是获取

   8）检查该Bean对象是否有依赖关系   有  获取依赖的Bean对象

   9）检查该Bean对象的类型（singleton，prototype类型）

  10）是Singleton 调用自动装配工厂产生该Bean对象的实例

  

---------------------------------------------------------------------------------------------------  
  mybatis
  使用

   持久层框架，让程序员将主要精力放到sql上，通过mybatis提供的映射方式，自由灵活生成满足需要的sql语句

   mybatis可以将向preparedStatement中输入参数自动进行输入映射，将查询结果集灵活映射成java对象（输出映射）

   重要组成部分就是SqlMap配置文件，文件的核心是Statement语句包括CRUD，通过解析SqlMap配置文件得到的所有Statement执行语句，同时会形成ParameterMap,ResultMap两个对象，用于处理参数和经过解析后交给数据库处理的SQL对象

   MyBatis的全局配置文件 mybatis-config.xml 设置setting和属性properties信息，数据库连接池等信息

   根据配置文件创建SqlSessionFactory  

   InputStream inputStream = Resource.getResourceAsStream("mybatis-config.xml");

   SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

   Mybatis通过sqlSession对象进行操作 

   SqlSession sqlSession = sqlSessionFactory.openSession();

   调用sqlSession的方法进行CRUD操作


   selectOne ：查询一条记录，如果查询多条记录则抛出异常

   selectList ：可以查询一条或多条记录

   sqlSession不是线程安全的，不能被共享，每次使用完都必须关闭


   MyBatis通过xml或注解的方式将要执行的这种statement（statement,preparedStatement,callableStatement）配置起来，并通过java对象和satement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回

  # $区别

   #{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。#{}可以接收简单类型值或pojo属性值。如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称 建议写成_parameterT

   ${}表示拼接sql串，通过${}可以将parameterTyep传入的内容拼接在sql中且不进行jdbc类型转换，${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value，一般不建议使用

   ${}的使用：order by



  Hibernate和MyBatis的异同：
   
     MyBatis可以使用直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发。但灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大

     Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，使用Hibernate可以节省很多代码，提高效率。但学习门槛高。




  数据映射过程 ：根据在Statement中定义的SQL语句，解析出其中的参数，按照其出现的顺序保存在Map集合中，并按照在Statemennt中定义的ParameterMap对象类型解析出参数的java数据类型，根据其数据类型构建TypeHandler对象，参数值的复制是通过DateExchange对象完成



  一级 二级缓存


  MyBatis的一级缓存

  local cache 即本地缓存，作用域默认为sqlSession，当Session flush或close后，该Session中的所有Cache将被清空

  本地缓存不能被关闭，但可以调用clearCache()来清空本地缓存，或者改变缓存的作用域

  同一次会话期间只要查询过的数据都会保存在当前SqlSession的一个Map中

  一级缓存失效的四种情况：
   1）不同的SqlSession对应不同的一级缓存

   2）同一个SqlSession但是查询条件不同

   3）同一个SqlSession两次查询期间执行了任何一次增删改操作

   4）同一个SqlSession两次查询期间手动清空了缓存



  MyBatis二级缓存

  second level cache，全局作用域缓存，默认不开启，需要手动配置

  MyBatis提供二级缓存的接口以及实现，缓存实现要求POJO实现Serializable接口

  二级缓存存在SqlSession关闭或提交之后才会生效

  使用步骤：

   1） 全局配置文件中开启二级缓存

       <setting name="cacheEnabled" value="true"/>
   2)  需要使用二级缓存的映射文件处使用cache配置缓存  <cache/>

   3)  注意 POJO需要实现Serializable接口


  MyBatis的批量操作：

  默认的openSession()方法没有参数，会创建如下特性：

  1）开启一个事务（也就是不自动提交）

  2）连接对象会从由活动环境配置的数据源实例得到
  
  3）事务隔离级别将会使用驱动或数据源的默认设置

  4）预处理语句不会被复用，也不会批量处理更新
  
  openSession方法ExecutorType类型的参数    

    ExecutorType.SIMPLE:默认装配，为每一个语句的执行创建一个新的预处理语句
   
    ExecutorType.REUSE:会复用预处理语句
 
    ExecutorType.BATCH: 批量执行所有更新语句


    批量操作使用Mybatis提供的BatchExecutor进行的，底层就是通过jdbc攒sql的方式进行的，可以让他攒够一定数量后发给数据库一次

    在于spring整合中，配置一个专门用来执行批量操作的sqlSession

    批量操作是在session.commit()以后才发送sql语句给数据库进行执行地

    如果想让其提前执行，以方便后续可能的查询操作获取数据，可以使用sqlSession.flushStatements()方法，让其直接冲刷到数据库进行执行


    ResultMap 和 ResultType 之间的联系区别

    两者都是表示结果集，将结果与java对象映射起来
   
    ResultMap 是通过在配置文件中通过<ResutlMap>标签配置的  可以通过TypeHandler进行类型转换

    ResultType 可以写一个java类型或Map  保证结果集的列名和java的字段名相同，不分大小写


--------------------------------------------------------------------------------------------------- 

9.设计模式


  单例模式
   懒汉式 双重加锁
   双重加锁时  synchronizedSingleton 对象必须使用volatile修饰 防止并发时的指令重排序
   
  if(synchronizedSingleton==null){
     synchronized(SynchronizedSingleton.class){
        if(synchronizedSingleton==null){
              synchronizedSingleton=new SynchronizedSingleton();
           }
     }    
  }
  return synchronizedSingleton;


  推荐使用静态内部类

  public class Singleton{
    
    prviate Singleton(){}

    private static class T{

      private static Singleton t = new Singleton();
    }

    public Singleton getInstance(){
        
      return T.t;
    }
  }
  


为什么要在同步块中有是否为null的判断：
  若A B两个线程都在同步块外面判断了是否为null， 结果为A首先获得锁，进入同步块创造一个实例，此时已经创建一个实例，A退出同步块，返回第一个实例，B此时进入同步块，正常情况下，应直接返回已经创建好的实例，但没有null判断，直接就是一条创建实例的语句，B此时就会再创建一个实例，就会造成创造了多个实例的情况

  双重加锁机制在jvm上可能出现的问题
  jvm创造一个新的对象是分好几步进行的，并不是一个原子性操作

  jvm创建对象的三步：
  1、分配内存 2、初始化构造器 3、将对象指向分配的内存的地址

  在这种顺序下并不会发生问题，若jvm针对字节码进行调优，2和3可能相反，就会出现问题，此时先将分配好的内存地址指给synchronizedSingleton，然后再进行初始化构造器，这时后面的线程去请求getInstance方法时，会认为对象已经实例化，直接返回一个引用，如果在初始化构造器之前线程使用了synchronziedSingleton，就会发生错误。



  单例模式的应用场景：

  1、数据库连接池

  2、spring中bean的管理

  3、java中servlet

  4、java中的监听器、过滤器

  5、数据库配置文件的读取DBinfo

  6、工厂类
  
--------------------------------------------------------------------------------------------------- 
             
  工厂模式

  工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程隔离起来，达到提高灵活性地目的

  分为三类：
  1）简单工厂模式（Simple Factory）又称静态工厂方法模式，存在的目的：定义一个用于创建对象的接口

  2) 工厂方法模式（Factory Method）

  3) 抽象工厂模式（Abstract Factory）

  三种模式从上到下逐步抽象，更具一般性

  区别：
   工厂方法模式：
   一个抽象产品类，可以派生出多个具体产品类
   一个抽象工厂类，可以派生出多个具体工厂类
   每个具体工厂类只能创建一个具体产品类的实例
   
   抽象工厂模式：
   多个抽象产品类，每个抽象产品类可以派生出多个具体产品类
   一个抽象工厂类，可以派生出多个具体工厂类
   每个具体工厂类可以创建多个具体产品类的实例


   工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个
   工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个









--------------------------------------------------------------------------------------------------- 
  观察者模式(发布-订阅模式）

  1、swing控件事件
  
  2、html控件事件-----onclick(),onblur()

  3、javaee事件 ------ServletRequestListener,HttpSessionListener,ServletContextListener

  
   
  
    




--------------------------------------------------------------------------------------------------- 
  适配器模式
--------------------------------------------------------------------------------------------------- 
  模板方法模式
    模板方法模式是类的行为模式，准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑，不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现，这就是模板方法的用意，是基于继承的代码复用的基本技术

--------------------------------------------------------------------------------------------------- 
  策略模式
--------------------------------------------------------------------------------------------------- 
  责任链模式
--------------------------------------------------------------------------------------------------- 
  装饰者模式

--------------------------------------------------------------------------------------------------- 
  代理模式
  代理类和委托类有相同的接口，一个代理类的对象与一个委托类的对象关联。代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法来提供特定的服务




  代理模式和装饰者模式的区别：
    代理模式一定是自身持有代理对象，在内部创建。而装饰模式一定是从外部传入，并且可以没有顺序，按照代码的实际需求随意调换顺序

    从使用角度看：代理模式注重的是隔离限制，让外部不能访问实际的调用对象
                  装饰模式注重的是功能的扩展


   
--------------------------------------------------------------------------------------------------- 
  1）常用的八种掌握就行  原理  使用
  2）单例 工厂 观察者重点
 
  
10.数据结构
 
  二叉树
   平衡二叉树
   又称AVL树，性质：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1，若将二叉树上结点的平衡因子BF定义为该节点的左子树和深度减去它的右子树的深度，则平衡树上所有结点的平衡因子只可能是-1,1,0
--------------------------------------------------------------------------------------------------- 
   二叉查找树
   二叉排序树，具有性质：若它的左子树不空，则左子树上所有的结点的值均小于它的根结点的值，若它的右子树不空，则右子树所有的结点的值都大于它的根结点的值；它的左，右子树也分别为二叉排序树。
   二叉排序树是一种动态树表，其特点是：树的结构通常不是一次生成的，而是在查找的过程中，当树中不存在关键字等于给定值的结点时在进行插入，新插入的结点一定是一个新添加的叶子结点，并且时查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点

   中序遍历可以得到一个关键字的有序序列
--------------------------------------------------------------------------------------------------- 
   红黑树
   
   是一颗平衡的二叉查找树，结点是红色或者黑色，通过颜色的约束来维持二叉树的平衡。检索效率为O(logn)
   规则：
   1）每个结点都只能是红色或者黑色
   2）根结点是黑色
   3）每个叶节点（NIL结点，空结点）是黑色的
   4）如果一个结点是红的，则它两个子结点都是黑色的，也就是说在一条路径上不能出现相邻的两个红色结点
   5）从任一结点到其每个叶子结点的所有路径都包含相同数目的黑色结点


   NIL结点：如果一个结点没有子结点或父结点，则该结点相应指针属性的值为NIL

   红黑树的基本操作：左旋 右旋

   红黑树的基本操作 添加
   1）将红黑树当作一颗二叉查找树，将节点插入
   2）将插入结点着色为红色
   3）通过一系列的旋转或者着色等操作，使之重新称为一颗红黑树
  
   红黑树解决插入问题的核心思想是：将红色的结点移到根结点，然后，将根结点设置为黑色

   case1: 当前结点的父结点是红色，且当前结点的祖父结点的另一个子结点（叔叔结点）也是红色
   处理方法： 将父结点设置为黑色  将叔叔结点设为黑色  将祖父结点设为红色  将组父结点设为当前结点（红色结点），即之后对继续对当前结点进行操作

   case2：当前结点的父结点是红色，叔叔结点是黑色，且当前结点是其父结点的右孩子
   处理方法：将父结点作为新的当前结点   以新的当前结点为支点进行左旋
  
   case3：当前结点的父结点是红色，叔叔结点是黑色，且当前结点是其父结点的左孩子
   处理方法：将父结点设为黑色   将祖父结点设为红色  以祖父节点为支点进行右旋






--------------------------------------------------------------------------------------------------- 
   完全二叉树
   深度为k的，有n个结点的二叉树，当且仅当其每个结点都与深度为k的满二叉树中编号从1至n的结点一一对应，称之为完全二叉树
--------------------------------------------------------------------------------------------------- 
   满二叉树
   一颗深度为k且有2的k次方-1个结点的二叉树称为满二叉树
--------------------------------------------------------------------------------------------------- 
   概念 适用场景 时间复杂度   好处坏处
--------------------------------------------------------------------------------------------------- 
  B树
  B-Tree  B+Tree

  B-树 是一种平衡的多路查找树 在文件系统中很有用 主要用作文件的索引
  一颗m阶的B-树，或为空，或满足下列特性：
  1）树中每个结点至多有m棵子树
  2）若根结点不是叶子结点，则至少有两棵子树
  3）除根之外的所有非终端结点之后有最小大于m/2棵子树
  4）所有的非终端结点 
  5）所有的叶子结点都出现在同一层次上，并且不带信息
  
  在B-树上进行查找的过程是一个顺指针查找结点和在节点的关键字中进行查找交叉进行的过程


  B+树 
  与B-树的差异：
  1）有n棵子树的结点中含有n个关键字
  2）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
  3）所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中最大（或最小）关键字

  通常在B+树上有两个头指针，一个指向根结点，另一个指向关键字最小的叶子结点

  可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根结点开始，进行随机查找

  两者的联系 区别 适用场景
--------------------------------------------------------------------------------------------------- 
  算法
  排序算法： 分为内部排序 和 外部排序
  内部排序分为：根据不同原则分： 插入排序 : 直接插入排序 希尔排序

                                 交换排序 ：冒泡排序 快速排序

                                 选择排序 ：简单选择排序 堆排序

                                 归并排序 

                                 基数排序   
 
                根据工作量分：简单排序 时间复杂度为O(n 的平方） 
                              先进的排序  O(nlogn)   堆排序  快排序  归并排序
                              基数排序 O（d*n)


  排序算法的稳定性：若待排序的序列中，存在多个具有相同关键字的记录，经过排序，这些记录的相对次序保持不变，则称该算法是稳定的，若经过排序后，记录的相对次序发生了改变，则称该算法是不稳定的

  稳定的排序算法：冒泡排序 直接插入排序 归并排序 和 基数排序

  非稳定的排序算法：选择排序，快速排序，希尔排序，堆排序

  选择排序算法准则：
   1.待排序的记录数目的n的大小

   2.记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小

   3.关键字的结构及其分布情况

   4.对排序稳定性的要求

  设待排序元素的个数为n

   1.当n较大时，则采用时间复杂度为O(nlog2n)的排序方法：快速排序，堆排序和归并排序

     快速排序:是目前基于比较的内部排序中被认为最好的方法，当待排序的关键字是随机分布使，快速排序的平均时间最短

     堆排序：如果内存空间允许且要求稳定性的

     归并排序：有一定数量的数据移动，可与插入排序组合，先获得一定长度的序列，再合并，效率得以提高

   2.当n较小时，可采用直接插入或直接选择排序

     直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数
   
     直接选择排序：元素分布有序，如果不要求稳定性，选择直接选择排序

   3.一般不使用或不直接使用传统的冒泡排序

   


---------------------------------------------------------------------------------------------------
  直接插入排序：

   基本思想：先将序列中的第一个记录看成一个有序的子序列，然后从第二个记录起逐个进行插入，直至整个序列变成关键字非递减有序序列为止
   代码实现：
      void InserSort(SqList &L){
        
           for(i=2;i<=L.length;i++){
              if(L.r[i].key<L.r[i-1].key){
                L.r[0]=L.r[i];  //复制为哨兵
                L.r[i]=L.r[i-1];
             
                for(j=i-2;L.r[0].key<L.r[j].key;j--)  //直接跳过了前一个  避免了重复后移
                    L.r[j+i]=L.r[j];//小于哨兵的后移一位
                L.r[j+1]=L.r[0];
              }
      }


     void InsertSort(int a[],int n){
	
	for(int i = 1; i < n; i++){
	
           if(a[i] < a[i-1]){  //若第i个元素大于i-1元素，直接插入，小于，移动有序表后插入
		int j = i - 1;
                int x = a[i];   // 复制为哨兵，即存储待排序元素
                a[i] = a[i - 1];  // 先后移一个元素  第一次后移
                while(x < a[j]){   //查找在有序表的插入位置       与上面的方法相比，此方法将前一个数后移了两次
                   a[j + 1] = a[j];                             // 这里会进行第二次后移
                   j--;            //元素后移   小心越界
                }
                a[j+1] = x;        //插入到正确的位置
           }
        }
     }
           


  
--------------------------------------------------------------------------------------------------- 
  二分插入排序 
  基本思想：在直接插入排序中，查找可以使用折半查找来实现
  代码实现：
     void BInsertSort (SqList &L){
       
          for(i=2;i<=L.length;i++){
              L.r[0]=L.r[i];
              low=1;high=i-1;
              while(low<=high){
                m=(low+high)/2;
                if(L.r[0]<L.r[m].key) 
                   high=m-1;
                else low=m+1;
              }
              for(j=i-1;j>=high+1;--j)
                  L.r[j+1]=L.r[j];
              L.r[high+1]=L.r[0];
          }
     }

  折半排序仅减少了关键字间的比较次数，而记录的移动次数不变
--------------------------------------------------------------------------------------------------- 
  希尔插入排序  又称“缩小增量排序”
  基本思想：先将整个待排序记录序列分割成为若个子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序
  代码实现：
    void ShellInsert( SqList &L,int dk){
        //r[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已经找到
        for(i=dk+1;i<=L.length;++i){
           if(L.r[i].key<L.r[i-dk].key){
               L.r[0]=L.r[i];
               for(j=i-dk;j>0&& L.r[0].key<L.r[j].key;j-=dk;)
                  L.r[j+dk]=L.r[j];
               L.r[j+dk]=L.r[0];
           }
        }
    }
   
   void ShellSort(SqList &L,int dlta[],int t){
      //按增量序列dlta[0...t-1]对顺序表L作希尔排序
      for(k=0;k<t;++k){
        ShellInsert(L,dltap[k]);
   }


   //跟直接插入排序相似
   void ShellInsertSort(int a[],int n,int dk){
	for（int i = dk;i < n; i++）{
           if(a[i] < a[i - dk]){
               int j = i - dk;
               int k = a[j];
               a[i] = a[i - dk];
               while(x < a[j]){
                   a[j + dk] = a[j];
                   j -= dk;
               }
               a[j + dk] = k;
           }
        }
    }

  
    void shellSort(int a[],int n){
        int dk = n/2;
        while(dk >= 1){
           ShellInserSort(a,n,dk);
           dk = dk/2;
        }
    }




--------------------------------------------------------------------------------------------------- 
  冒泡排序
  基本思想：首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序，则将两个记录交换，然后比较第二个记录和第三个记录的关键字，依次类推，直至第n-1个记录和第n个记录的关键字进行比较为止
  代码实现：
  void bubble_sort(int a[],int n){
   
       for(i=n-1,change=true;i>=1&&change;--i){
         change=false;
         for(j=0;j<i;j++)
           if(a[j]>a[j+1]){
             int temp=a[j];
             a[j]=a[j+1];
             a[j+1]=temp;
             change=true;
           }
       } 
  }


  void bubbleSort(int a[], int n){

      for(itn i = 0; i < n - 1; i++){
         for(int j = 0; j < n - i -1; j++){
            if(a[j] > a[j+1]){
               int tmp = a[j];
               a[j] = a[j+1];
               a[j+1] = tmp;
            }
         }
      }
  }


  传统的冒泡排序中每一趟排序操作只能找到一个最大值或最小值，现在考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值（最大值和最小值），从而使排序趟数几乎减少一半
  void Bubble_2 (int r[], int n){
      int low = 0;
      int high = n - 1;
      int tmp,j;
      while(low < high){
           for(j = low,j < high, j++){
              if(r[j] > r[j + 1]){
                tmp = r[j]; r[j]=r[j + 1]; r[j + 1]=tmp;
              }
              high--;
           }

           for(j = high;j > low; j--){
              if(r[j] < r[j - 1]){
                tmp = r[j]; r[j] = r[j - 1]; r[j - 1] = tmp;
              }
              low++;
           }
      }
   }

--------------------------------------------------------------------------------------------------- 
  快排
  基本思想：是对冒泡排序的一种改进，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序
  代码实现：
  int Partition(SqList &L,int low,int high){
     
      L.r[0]=L.r[low];
      pivotkey=L.r[low].key;
      while(low<high){
        while(low<high && L.r[high].key>=privotkey)
              --high;
        L.r[low]=L.r[high];
        while(low<high && L.r[low].key<=privotkey)
              ++low;
        L.r[high]=L.r[low];
      }
      L.r[high]=L.r[low];
      return low;
  }

  void QSort(SqList &L,int low,int high){
    
      if(low<high){
         pivotloc=Partition(L,low,high);
         QSort(L,low,pivotloc-1);
         QSort(L,pivotloc+1,high);
      }
  }

  快速排序是通常被认为在同数量级（O（nlog2n））的排序方法中平均性能最好的，但若初始序列按关键码有序或基本有序时，快排序反而退化为冒泡派速，为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点单个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法

--------------------------------------------------------------------------------------------------- 
  选择排序
  基本思想：每一趟在n-i+1(i=1,2.....,n-1)个记录中选取关键字最小的记录作为有序序列中的第i个记录
   
     第一趟：从n个记录中找出关码最小的记录与第一个记录交换
     第二趟：从第二个记录开始的n-1个记录中再选出关键码最小的记录与第二个记录交换；
     依次类推
     第i趟：从第i个记录开始的n-i+1个记录中选出关键码最小的记录与第i个记录交换，直到整个序列按关键码有序





  简单选择排序： 时间复杂度： O(n的平方)

  void SelectSort(SqList L）{
      for(i=1;i<L.length;++i){
           j=SelectMinKey(L,i);
           if(i!=j) L.r[i]<-->L.r[j];
      }
  }


**************************************************************************************************
  int SelectMinKey(int a[], int n, int i){
        
       int k = i;
       for(int j = i + 1; j < n; j++){
          if(a[k] > a[j]){
             k = j;
          }
       return k;
   }


   void selectSort(int a[], int n){

      int key,tmp;
      for(int i = 0; i < n; i++){
         key = SelectMinKey(a,n,i);
         if(key != i){
            tmp = a[i];
            a[i] = a[key];
            a[key] = tmp;
         }
      }
    }
**************************************************************************************************

  void selectSort(int a[]){

      int len = a.length;
      for(int i = 0;i < len - 1; i++){

         for(int j = i + 1; j < len ;j++){
             if(a[j] < a[i]){
                 swap(a, j ,i);
             }
         }
      }
  }
--------------------------------------------------------------------------------------------------- 

  简单选择排序的改进-----二元选择排序

     简单选择排序，每趟循环只能确定一个元素排序后的定位，改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置，从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可


     void SelectSort(int r[],int n){
        int i,j,min,max,tmp;
        for(i = 1;i <= n/2; i++){
          min = i;
          max = i;
        for(j = i + 1; j <= n - i;j++){
           if(r[j] > r[max]){
              max = j;
              continue;
           }
           if(r[j] < r[min]){
              min = j;
           }
        }

       tmp = r[i - 1]; r[i - 1] = r[min]; r[min] = tmp;
       tmp = r[n - i]; r[n - i] = r[max]; r[max] = tmp;
     }






--------------------------------------------------------------------------------------------------- 
  堆排序

  只需要一个记录大小的辅助空间，每个待排序的记录仅占有一个存储空间
  堆的含义表明：完全二叉树中所有非终端结点的值均不大于（或均不小于）其左，右孩子结点的值，

  一般都采用数组来表示堆，i结点的父节点下标就为(i-1)/2,它的左右子结点下标分别为2*i+1,2*i+2  结点从0开始

  基本思想：（大顶堆）

  时间复杂度：O(nlogn)  不稳定  对n较大时使用

  1）将初始待排序关键字序列构成大顶堆，此堆为初始的无序区
  2）将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区和新的有序区
  3）由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区调整为新堆，然后再次将R[1]于无序区最后一个元素交换，不断重复此过程直到有序区的元素个数为n-1,

   操作过程：
     初始化堆，将R[1..N]构造为堆
     将当前无序区的堆顶元素R[1]同该区的最后一个记录交换，然后将新的无序区调整为新的堆


     堆排序需要两个过程：一是建立堆，二是堆顶与堆的最后一个元素交换的位置，所以堆排序有两个函数组成，一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数


     n个元素初始建堆的过程：
     
       1）n个结点的完全二叉树，则最后一个结点是第[n/2]个结点的子树
    
       2）筛选从第[n/2]个结点为根的子树开始，该子树成为堆

       3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根节点  





  
  代码实现：
    void HeapAdjust(HeapType H,int s, int m){

        rc=H.r[s];
        for(j=2*s;j<=m;j*=2){
   
           if(j<m && H.r[j].key<H.r[j+1].key)
               ++j;
           if(rc.key>r[j].key)
               break;
  
           H.r[s]=H.r[j];
           s=j;
        }
        H.r[s]=rc;
   }
  
   void HeapSort(HeapType H){
   
       for(i=H.length/2;i>0;--i){     //将无序表变为大顶堆
          HeapAdjust(H,i,H.length);   
       }

       for(i=H.length;i>1;--i){   //将堆顶和最后一个顶点 交换  再将剩余部分进行堆排（变为大顶堆）
          H.r[1]<--->H.r[i];

          HeapAdjust(H,1,i-1);   
       }
  
--------------------------------------------------------------------------------------------------- 
  归并排序
  
  归并：将两个或两个以上的有序表组合成一个新的有序表
  2-路归并：将一维数组中前后相邻的两个有序序列归并为一个有序序列  时间复杂度：O（nlogn)  是一种稳定的排序方法

  代码实现：
   
   void  Merge(RcdType SR[],RcdType TR[], int i,int m,int n){
      //将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]

      for(j=m+1,k=i;i<=m && j<=n;++k){
  
         if(SR[i].key<=SR[j].key)
            TR[k]=SR[i++];
         else
            TR[k]=SR[j++];
      }
   
      if(i<=m) TR[k..n]=SR[i..m];
      if(j<=m) TR[k..n]=SR[j..n];
   }

**************************************************************************************************

   public static void guibing(int [] a){
      int len = a.length;
      mergesort(a,0, len - 1);
   }

   private static void mergesort(int [] a, int start, int end){
      if(start < end){
         int mid = (start + end) / 2;
         mergesort(a, start, mid);
         mergesort(a, mid + 1, end);
         mergepaihaoxu(a,start,mid,mid + 1,end);
      }
   }

   private static void mergepaihaoxu(int a[], int start1, int end1, int start2, int end2){
      int i = start1;
      int j = start2;

      int [] t = new int[end2 - start1 + 1];
      int k = 0;
      while(i < = end1 && j <= end2){
         if(a[i] < a[j]){
            t[k] = a[i];
            i++;
            k++;
         }else{
            t[k] = a[j];
            j++;
            k++;
         }
      }

      while(i <= end1){
         t[k++] = a[i++];
      }
      while(j <= end2){
         t[k++] = a[j++];
      }
     
      for(int m = 0; m < t.length;m++){
         a[m + start1] = t[m];
      }
   }
      



--------------------------------------------------------------------------------------------------- 
  1）各种排序的思想
  2）实现复杂度
  3）稳定性如何
  4）可以手写

  
11.网络
  
  TCP
  三次握手 四次挥手 各种状态 状态改变  
  和UDP的区别

   TCP/UDP区别：
  
   UDP:  无连接、尽最大努力交付、面向报文、没有拥塞控制、支持一对一，一对多，多对一和多对多的交互通信、首部开销小，只有8个字节

   TCP:  是面向连接的运输层协议、每一条TCP连接只能有两个端点、提供可靠交付的服务、提供全双工通信、面向字节流
   TCP连接的端点是个很抽象的套接字，即（ip地址 ：端口号）



   可靠传输的工作原理：
   1）停止等待协议（自动重传请求ARQ）
   2）连续ARQ协议

   TCP报文段的首部格式：
   1) 源端口和目的端口 
   2）序号 在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号
   3）确认号 是期望收到对方下一个报文段的第一个数据字节的序号
   4）数据偏移 最大值是60个字节 
   5）保留
   6）紧急URG 
   7）确认ACK 仅当ACK=1时确认号才有效 ，TCP规定，在连接建立后所有传送的报文段都必须把ACK置1
   8）推送PSH
   9）复位RST
   10）同步SYN 在连接建立时用来同步序号，当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使用SYN=1和ACK=1，因此，SYN置为1就表示这是一个连接请求或连接接收报文
   11）终止FIN
   12）窗口  指的是发送本报文段的一方的接收窗口，窗口值作为接收方让发送方设置其发送窗口的依据，窗口字段明确指出了现在允许对方发送的数据量，窗口值是经常在动态变化着
   13）检验和 14）紧急指针 15)选项 


  TCP的流量控制：让发送方的发送速率不要太快，要让接收方来得及接收
   传输效率的控制 ： 使用Nale算法：若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来，当发送方收到第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段确认后才继续发送下一个报文段，当数据到达较快而网络速率较慢时，用这样的方法可以明显减少所用的网络的带宽，算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段，这样做，可以有效的提高网路的吞吐量。

--------------------------------------------------------------------------------------------------- 
  IO模型
  同步 异步 阻塞 非阻塞的概念
  模型种类 各自特点 适用场景
  如何使用
   
  同步和异步：

    同步就是一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成，这是一种可靠的任务序列。要成功都成功，要失败都失败，两个任务的状态可以保持一致。

    异步不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成整个任务就算完成了。至于被依赖的任务最重是否真正完成，依赖它的任务无法确定，所以它不是可靠的任务序列

    可以用打电话和发短信来很好的比喻同步和异步操作


  阻塞和非阻塞：

    阻塞和非阻塞主要是从CPU的消耗上来说的

    阻塞就是CPU停下来等待一个慢的操作完成以后，CPU才接着完成其他的工作。
 
    非阻塞就是在这个慢的操作执行时,CPU去做其他工作，等这个慢的操作完成时，CPU再接着完成后续的操作。虽然从表面上看非阻塞的方式可以明显得提高CPU的利用率，但是也带来了另外一种后果，就是系统的线程切换增加。增加的CPU使用时间能不能补偿系统的切换成本需要好好评估
    

    有四种不同的组合方式：

    1）同步阻塞：最常用的一种用法，使用也是最简单的，但是I/O性能一般很差，CPU大部分处于空闲状态
 
    2）同步非阻塞：提升I/O性能的常用手段，就是将I/O的阻塞改成非阻塞方式，尤其在网络I/O是长连接同时传输的数据也不是很多的情况下，提升性能非常有效。这种方式通常能提升I/O性能，但是会增加CPU消耗，要考虑增加的I/O性能能不能补偿CPU的消耗，也就是系统的瓶颈是在I/O上还是在CPU上

   
    3）异步阻塞：这种方式在分布式数据库中经常用到，例如：在一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，还有2-3份备份记录会写到其他机器上，这些备份记录通常都采用异步阻塞的方式写I/O
       异步阻塞对网络I/O能够提升效率，尤其像上面这种同时写多分相同数据的情况

    4）异步非阻塞：这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，集群之间的消息同步机制一般用这种I/O组合方式
       它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大却非常频繁的情况，这种网络I/O用这种方式性能能达到最高






--------------------------------------------------------------------------------------------------- 
  POST和GET方式的不同?
  GET方法会将请求参数及参数值放在请求资源路径里面，携带的数据大小有限制，不适合提交大量的数据
  POST方式会将请求参数及参数值放在实体内容里面，理论上没有限制，适合大量数据的提交

  安全上来讲，post方式相对安全（因为请求参数及值存放在实体内容里面，而get方式会将请求参数及值显示在浏览器地址栏），但是要注意，post方式并没有将数据加密

--------------------------------------------------------------------------------------------------- 
 
12.Linux基础

   常用命令

   ll -h
   ls -a 查出所有文件和文件夹  包含隐藏的

   mkdir -p
   rmdir

   touch  作用有两方面：1.用于把已存在文件的时间标签更新为系统的当前时间，他们的数据将原封不动地保留下来

                        2.用来创建新的空文件
    



   vim
   rpm -e --nodeps 卸载
   
   rpm -ivh  本地程序安装

   rpm -qa  本地程序查看

   pwd 显示当前所在目录

   tar -zcvf
   tar -zxvf  -C
   grep -i
   ps -ef 
   cd
   cp
   mv
   

   rm -rf

   find 查找文件

   kill

   ifconfig

   ping
  
   reboot

   chmod

   chown

   yum


   
   管道符
   
   查看日志相关命令

   cat
   more 文件名 分页显示文件
  
   less -mN 文件名  标注行号

   head 从头部开始查看

   tail -数字 文件名  快速查看文件后x行的内容

  
   CPU使用命令

   top 查看每个进程的cpu

   free 看内存

--------------------------------------------------------------------------------------------------- 

13.Collection和Collections的区别

  java.util.Collection是一个集合接口，提供了对集合对象进行基本操作的通用接口方法。Collection接口在java类库中有很多具体的实现，Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。

  java.util.Collections是一个包装类，包含有各种有关集合操作的静态动态方法，此类不能实例化，就像一个工具类，服务于java的Collection框架

--------------------------------------------------------------------------------------------------- 

14.Statement和PreStatement有什么区别，那个性能更好？
   与statement相比 
   1）PreStatement接口代表预编译的的语句，主要优势是可以减少SQL的编译错误，并增加SQL的安全性，（减少SQL注入攻击的可能性）
   2）PreStatement中的SQL语句是可以带参数的，避免使用了用字符串连接拼接SQL语句的麻烦和不安全
   3）当批量处理SQL或频繁执行相同的查询时，PreStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同的语句时就会很快（不用再次编译和生成执行计划）



--------------------------------------------------------------------------------------------------- 
15.进行数据库编程时，连接池有什么作用？
   由于创建连接和释放连接都有很大的开销（尤其是数据库不在本地时，每次创建连接都需要进行TCP的三次握手，释放连接时需要进行四次挥手，开销很大），为了提高数据的性能，可以实现创建若干的连接置于连接池中，需要时直接从池中获取，使用结束时，放回池中，避免频繁创建和释放连接所造成的开销，这是典型的空间换时间的策略).

   基于java开源数据库连接池主要有C3P0,Proxool,DBCP,BoneCP,Druid等


---------------------------------------------------------------------------------------------------
16.JDBC中如何进行事务处理？
   Coonection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务，当事务完成后用commit()显示提交事务，如果在事务中出现异常则通过rollback()进行事务的回滚，除此之外，从JDBC 3.0中还引入了Savepoint(保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。

--------------------------------------------------------------------------------------------------- 
17.重载的静态分派  （即根据静态类型 看左边）

   编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的，并且静态类型是编译期可知的，因此，在编译阶段，javac编译器会根据参数的静态类型决定使用哪个重载版本。
   
   静态多分派


   重写的动态分派   （即根据实际类型 看右边）

   动态单分派

--------------------------------------------------------------------------------------------------- 
18.数据库中什么是索引

   是排好序的快速查找数据结构  索引会影响查找和排序  where 和order by

   索引本身也很大，不能全部存储在内存中，因此索引以文件的形式存在磁盘中。

   优势：类似大学图书建书目索引，提高数据检索的效率，降低数据库的IO成本，通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。

   劣势：虽然索引大大提高了查询速度，同时会降低更新表的速度，如对表的INSERT\UPDATE\DELETE操作，更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新带来的键值变化后的索引信息

   分类 ： 单值索引  唯一索引  复合索引

--------------------------------------------------------------------------------------------------- 
  聚簇索引和非聚簇索引
  MyIsam索引和数据的关系：主索引和次索引指向行在磁盘上的位置 （数据文件在磁盘上，每行都有自己的地址）

  Innodb 在主键索引的树中，直接储存行的数据 ，称为聚簇索引。次索引都指向主键的引用

  注意：Innodb来说
   主键索引，既存储索引值，又在叶子中存储行的数据
   如果没有主键，则会将Unique key作为主键
   如果没有Unique key，则系统会生成一个内部的rowid作为主键
   像Innodb，主键索引中既存储主键值又存储行数据，这种结构称为“聚簇索引”

   聚簇索引 
     优势：根据主键查询条目比较少时，不用回行（数据就在主键节点下）
     劣势：如果碰到不规则数据插入时，造成频繁的页分裂
 
   聚簇索引的主键值，应尽量是连续增长的整型值，而不要是随机值

--------------------------------------------------------------------------------------------------- 

  数据库中索引的数据结构？

   一般关系型数据库使用B+树来做索引，NoSQL数据库用哈希来做索引

  为什么用B+树不用红黑树？

   因为索引本身很大，不能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上，这样在使用索引的时候要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引最重要的指标就是在查找的过程中磁盘I/O操作次数的渐进复杂度

   因为B+树分支多层数少，并且所有的叶子结点包含了所有的关键字信息，有n棵子树的节点中含有n个关键字，所以内结点的出度d大，d越大索引的性能越好，且结点中包含数据信息，所以拥有更好的性能


--------------------------------------------------------------------------------------------------- 
19.内存模型

   在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。

   java内存模型：来屏蔽掉各种硬件和操作系统的内存访问差异，让实现java程序在各种平台下都能达到一致的内存访问效果。

   java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节

   线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作，都必须在工作内存中进行，而不能直接读写内存中变量，不同的线程之间也无法访问对方工作内存中的变量，线程之间变量值的传递均需要通过主内存来完成。


   对于volatile 只能保证变量的可见性  防止指令重排序  并不能保证操作的原子性
   
   java内存模型是围绕着在并发过程中如何处理原子性，可见性和有序性这三个特征建立的。

--------------------------------------------------------------------------------------------------- 
20.java中的线程安全

   何为线程安全：
    当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其它的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象时线程安全的

   java语言中各种操作共享的数据分为5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立
   
   javaAPI中符合不可变要求的类型有 String、枚举类型及java.lang.Number的部分子类


   线程安全的实现方法：
   1）互斥同步

      最主要的问题是进行线程阻塞和唤醒所带的性能的问题，也叫阻塞同步，属于一种悲观的并发策略，
      互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式 

      java中基本的互斥手段是synchronized关键字。
   
      synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的队形

      synchronized同步块对同一条线程来说是可重入的，同步块在已进入的线程执行完成之前，会阻塞后面的其它线程的进入，由于java线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，要耗费很多处理器的时间，所以性能开销大，是重量级的同步机制。

   2）非阻塞同步  乐观的并发策略  不需要把线程挂起，是基于冲突检测

      先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，产生了冲突，那就再采用其他补偿措施（最常见的补偿措施就是不断地重试，直到成功为止）

      使用有要求：需要硬件指令集的发展才能使用，因为需要操作和冲突检测这两个步骤具备原子性，这类常用的指令有：

      测试并设置（Test-and-Set）  获取并增加（Fetch-and-Increment） 交换（Swap） 比较并交换（Compare-and-Swap CAS） 加载链接/条件存储（Load-Linked/Store-Conditional LL/SC）

      CAS需要三个操作数：分别是内存位置（变量的内存地址，用V表示）、旧的预期值（用A表示）、新值（用B表示）。当CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V值，否则它就不执行更新，但是是否更新了V的值，都会返回V的旧值，这个处理过程是一个原子操作、

      CAS的问题：ABA问题---如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查仍为A值，但是在这期间曾被改为了B，后又在检查之前改回了A，那么CAS就会误认为它从来没有被改变过

     解决方法：java提供了一个带有标记的原子引用类“AtomicStampedReference”,它可以通过控制变量的版本来保证CAS的正确性，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效

   3) 无同步方案  

      要保证线程安全，并不是一定要进行同步，两者没有因果关系，同步只是保证共享数据争用时的正确性手段，如果一个方法本来就不涉及共享数据，那么它自然就无须任何同步措施去保证正确性

       
 
      可重入代码（纯代码）：可以在代码执行的任何时刻中断它，转而执行另一段代码，而在控制权返回后，原来的程序不会出现任何错误。

      判断代码是否具备可重入性：如果一个方法，它返回的结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也是线程安全的

      线程本地存储   ThreadLocal 线程局部变量

      每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量

--------------------------------------------------------------------------------------------------- 
21.锁优化
    自旋锁：在互斥同步中阻塞唤醒造成性能降低，因此可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，为了让线程等待，只需要让线程执行一个忙循环（自旋），这就是所谓的自旋锁。自旋次数默认为10次  可以使用参数-XX:PreBlockSpin来更改

    JDK1.6中默认开启

    自适应自旋锁：JDK1.6引入 自适应意味着自身的时间不再固定了，而是有前一次在同一个锁上的自旋时间及锁的拥有者的状态了决定的。

    锁消除 ： 指的是虚拟机即使编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行

    锁粗化 ： 如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部

    轻量级锁 ：JDK1.6之中新加入的新型锁机制，本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗

       对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄，官方称为“Mark Word”,它是实现轻量级和偏向锁的关键，另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度

       在代码进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Rcord）的空间，用于存储锁对象目前的Mark Word的拷贝，然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，如果更新操作失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有了这个对象的锁，如果不是，则说明这个锁对象已经被其他线程占用了，此时轻量级锁不再有效，要膨胀为重量级锁。

    偏向锁：是JDK1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能，如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CSA操作都不做了
--------------------------------------------------------------------------------------------------- 
22.Hibernate

   get和load方法有什么不同之处

   最大区别是，如果在缓存中没有找到相应的对象，get将会直接访问数据库并返回一个完全初始化好的对象，这个过程可能会涉及到多个数据库的调用；而load方法在缓存中没有发现对象的情况下，只会返回一个代理对象，只有对象getId()方法之外的其他方法被调用时才会真正去访问数据库，这样做在某些情况可以提高性能
   当查询的记录不存在时，get方法会返回空NULL  load方法会抛出一个异常
 
   SessionFactory有什么作用，是否是线程安全的？
 
   SessionFactory是一个用于创建Hibernate的session对象的工厂，通常在启动时就创建好，它是线程安全的，不可变的

  
   Session指的是什么，是否可以将单个session在多个线程间进行共享？

    session负责维护同数据库的连接并且不是线程安全的，不能进行共享


    session的创建 在HibernateSessionFactory类中，使用静态代码块创建sessionFactory对象，单例模式，创建session 使用sessionFactory.openSession()方法，使用了ThreadLocal（局部变量）保证每个线程都有一个属于自己的session 

     private static final ThreadLocal<Session> threadLocal = new ThreadLocal<Session>();

   Hibernate的主键自增长策略：

   1）increment 用于为long,short或者int类型生成唯一标识，只有在没有其他进程往同一张表中插入数据时才能使用，在集群下不要使用

   2）identity 
      对DB2，MySQL,MS SQL Server,Sybase和HypersonicSQL的内置标识字段提供支持，返回的标识符是long,short或者int类型的

   3）sequence
      在DB2，PostgreSQL,Oracle,SAP DB,McKoi中使用序列（sequence）,而在InterBase中使用生成器（generator），返回的标识符是long,short或者是int类型的
  
   4）uuid
      用一个128-bit的UUID算法生成字符串类型的标识符，在这一个网络中是唯一的（使用了IP地址），UUID被编码为一个32位16进制数字的字符串

      生成策略： 使用了主机的网卡地址+随机数

   5）native  根据底层数据库的能力选择identity,sequence或者hilo中的一个

   6）assigned 让应用程序在save()之前为对象分配一个标识符，这是<genraotr>元素没有指定时的默认生成策略


   Hibernate中关系映射配置中cascade和inverse的区别:

    cascade: 主要用于级联操作（如：级联添加，删除）
  
    inverse: 主要用于控制权是否要翻转，一般将控制权放在多方， true代表控制权要翻转 默认值为false


--------------------------------------------------------------------------------------------------- 
23.类锁和对象锁的区别？

   类锁用来修饰静态的方法或代码块
   对象锁修饰普通方法或代码块
 
   类锁只是一个概念的东西，并不是真实存在，它是用来帮助我们理解锁定实例方法和静态方法的区别，使用的Class对象  xxx.class



--------------------------------------------------------------------------------------------------- 
24.java8的一些新特性

  1）Lambda表达式 和 函数式接口

     Lambda是一个匿名函数  一段可以传递的代码

     函数式接口：只包含一个抽象方法的接口   使用@FunctionalInterface注解可以检查是否是一个函数式接口，作为参数传递Lambda表达式：为了将Lambda表达式作为参数传递，接收Lambda表达式的参数类型必须是与该Lambda表达式兼容的函数式接口类型

    java内置四大核心函数式接口： Consumer<T> 消费型接口  Supplier<T> 供给型接口  Function<T,R>函数型接口  Predicate<T> 断定型接口
        


  2）接口的默认方法和静态方法
  
    默认方法使用default关键字修饰



  3）方法的引用
     
     对象::实例方法  类::静态方法  类::实例方法

     构造器引用 ClassName::new

  4）重复注解

  5）Optional接口

     避免NullPointerException异常

  6）Stream接口  串行和并行

     是java8中处理集合的关键抽象概念，可以对指定的集合List Set(Map除外）进行操作
   
     Stream自己不会存储元素  不会改变源对象，会返回一个持有结果的新Stream，操作是延迟的  
  
  7) Date API
  
--------------------------------------------------------------------------------------------------- 

25.为什么在重写equals方法的同时，必须重写hashcode方法

   比如在使用set集合时，往其中放入内容相同的对象，如果没有重写hashcode()方法，那么set中将会放入内容相同的对象（因为两个对象的地址不同），这和set集合的性质不同。因此需要在重写equals()方法的同时，重写hashcode方法


--------------------------------------------------------------------------------------------------- 
26.session和cookie

   cookie是由website创建，并发送到客户端浏览器存储的一些数据，在客户端浏览器访问website时，每一个http请求都会把所有的cookie传回给website
  
   cookie时<key,value>的结构，而且它的value只能存储Stirng   ex:  user:tom,12345
 
   cookie大小有限制，不能超过4k

   cookie的使用场景：

   1）sessionid的存储
   2）购物车（客户端的cookie存储，服务器的session存储，数据库存储）
   3）自动登录

   cookie的生命周期 

   public void setMaxAge(int expiry) 默认设置为-1  当浏览器关闭时，cookie失效

   cookie不能跨区使用
   
   cookie是基于客户端某个浏览器的，多个浏览器之间cookie不能共享


   session 在web server存储客户端这次回话中需要的数据

   生命期：
    
     当客户端第一次访问web site时，servlet container自动创建session对象--sessionid，并存储到cookie里，设置生命期为-1

     void setMaxInactiveInterval(int interval) 设置最大间隔时间
     当最后一次访问时间，与当前时间的间隔超过了设定值，服务器会主动回收session数据，即session失效了,此时session正式死亡

     当客户端关闭浏览器时，只是丢失了sessionid，但是服务器并不知道；session没有马上失效，只有超过了最大间隔时间无人访问，才会失效

     request.getSession().invalidate();    //主动清除会话中的所有数据

   
   在集群环境的中session的共享问题

      session数据存储在web server中，当使用集群时，多台机器无法共享session，此时通用做法是存储在redis中


   session对象在服务器端是如何存储的？

      Map<String,HttpSessionImpl> allSessions; //Tomcat维护所有的session对象

      request.getSesstion.setAttribute("user",user);  //用户数据必须要放到session对象中

      request.getSession() 的过程，Servlet是单例，调用service方法，这是一个多线程，高并发的环境，通过request对象，可以把客户端的sessionid携带过来，通过sessionid可以找到对应的session对象
  

--------------------------------------------------------------------------------------------------- 

27.在Tomcat启动时加载配置文件，有几种方法？

   1）过滤器的init()加载

   2）监听器 ServletContextListener的contextInitialized()

   3) 在servlet中，需要设置servlet启动时即加载

     <servlet>
        <load-on-startup>1</load-on-startup>
     </servlet>


---------------------------------------------------------------------------------------------------
28.多线程的安全问题

   在读表的时候发生删除情况怎么办？

   在select时加上for update 行锁（悲观锁） 加上锁后无法删除，行锁对读无影响       
  
   开启事务，启动了一个缓冲区，update,delete 会在表中进行加锁

   
   在插入时的情况，保证不影响读

   加表锁 再进行读   lock talbe 就无法插入  



---------------------------------------------------------------------------------------------------
29.java中事务的实现

   Connection接口中API:
     setAutoCommit(false);//手动开启事务

     commit();事务提交

     rollback();事务回滚
  
   扩展：了解Savepoint还原点
     void rollback(Savepoint savepoint) 还原到还原点
     Savepoint setSavepoint() 设置还原点

---------------------------------------------------------------------------------------------------
30.HTTP的请求方法：
   GET ：获取被请求URI(Request-URI)指定的信息（以实体的格式），请求的响应是可缓存的（cacheable）（获取信息）
 
   POST ：被用于请求源服务器接受请求中的实体作为请求资源的一个新的从属物。（提交信息） 方法的响应是不可缓存的

   PUT : 请求服务器去把请求里的实体存储在请求URI(Request-URI)标识下。如果请求URI（Request-URI）指定的资源已经在资源服务器上存在，那么此请求里的实体应该被当作是源服务器关于此URI所指定资源实体的最新修改版本（就是更新信息）

   DELETE ：请求源服务器删除请求URI指定的资源（删除资源）

   OPTIONS : 表明请求想得到请求/响应链上关于此请求里的URL（Request-URL）指定资源的通信选项信息。请求的响应是不可缓存的

   HEAD ：此方法被用来获取请求实体的元信息而不需要传实体主体（entity-body）。此方法经常被用来测试超文本链接的有效性，可访问性，和最近的改变。请求的响应的可缓存的

   TRACE ：被用于激发一个远程的，应用层的请求消息回路（TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请求返回一个响应，这就是一个请求响应回路）。TRACE请求不能包含一个实体

   CONNECT：此方法是为了能动态切换到隧道的代理（如SSL tunnelingfhi）

---------------------------------------------------------------------------------------------------
31.Nginx
   
   是一款轻量级的web服务器/方向代理服务器及电子邮件（IMP/POP3）代理服务器

   特点：反向代理 负载均衡  动静分离

   反向代理：理解正向代理：需要用户手动的设置代理服务器的ip和端口号，反向代理代理服务器的，用户不需要设置

   动静分离：将静态的资源放到反向服务器，节省用户的访问时间


  负载均衡

  负载均衡服务器分为两种，对一种是通过硬件实现的负载均衡器，简称硬负载。 例如：f5 

  另一种是通过软件来实现负载均衡，简称软负载，例如 Apache 和 Nginx

  硬负载和软负载相比，前者做的网络层次比较多，可以作用到socke接口的数据链路层，对发出的请求进行分组转发，但是价格成本比较贵，而软负载作用的层次在http协议层之上，可以对http请求进行分组转发并且因为是开源的，所有几乎是0成本

   
  请求负载过程中会话信息不能丢失，需要在多个服务器间共享session
  配置tomc的session共享可以有三种解决方案：

   1）以负载均衡服务器本身提供的session共享策略，每种服务器的配置是不一样的并且Nginx本身是没有的

   2）利用web容器本身的session共享策略来配置共享，针对于weblogic这种方式还是靠谱的，但是针对于tomc这种方式存在很大的缺陷，主要是因为依靠广播来实现的sessoin复制，会浪费很多带宽导致整个网络反应缓慢，官网也建议这种方式最好不要超过4台Tomcat

   3）Tomcat集群+redis的session共享配置方法

   nginx的解决方法： 在配置文件中upstream 中添加ip_hash
  
   使用Nginx搭建集群

   配置代理的服务器

   在location / 下添加反向代理 

        proxy_pass 代理服务器
    只代理一台服务器

   代理集群

      需要在http结点上添加
         upstream server_jiqun{
             server 主机ip+端口
             server 主机ip+端口
         }
      修改location /下的反向代理  proxy_pass http://servlet_jiqun
   

---------------------------------------------------------------------------------------------------
32.使用泛型的好处？
   
   泛型是jdk1.5之后出现的新特性，用于解决安全问题，是一个类型安全机制。

   好处：
    1）将运行期间出现的问题ClassCastException，转移到编译期时期方便程序员解决问题，让运行时期间减少出错，安全
   
    2）避免了强制转换的麻烦

   泛型的实现是靠类型擦除技术，在编译期完成的，编译期会将泛型的类型参数都擦除成它的限定类型，如果没有限定类型则擦除为Object类型后在获取的时候再强制类型转换为对应的类型，在运行期间并没有泛型的任何信息




---------------------------------------------------------------------------------------------------

33. 网络地址的分类

    A 类 1-126  0和127不作为A类地址，127保留给内部回送函数  0表示该地址是本地宿主机
    
    网络掩码 255.0.0.0 
   
    B 类 128-191
    
    网络掩码 255.255.0.0
   
    C 类 192-223
  
    网络掩码 255.255.255.0

---------------------------------------------------------------------------------------------------

34.分布式和集群

   分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行地任务数来提升效率的

   集群的概念：
     两大关键特性：  
       可扩展性 ：集群的性能不限于单一的服务实体，新的服务实体可以动态地加入到集群，从而增强集群的性能

       高可用性 ： 集群通过服务实体冗余使客户端免于轻易遇到out of service的警告

     两大能力：
       负载均衡：

       错误恢复： 由于某种原因，执行某个任务资源出现故障，另一服务实体中执行同一任务的资源接着完成任务，这种由于一个实体中的资源不能工作，另一个实体中的资源透明的继续完成任务的过程叫做错误恢复

     两大技术：
       集群地址：集群由多个服务实体组成，集群客户端通过访问集群的集群地址后去集群内部各服务实体的功能，具有单一集群地址是集群的一个基本地址。
       维护集群地址的设置被称为负载均衡器，负载均衡器的内部负责管理各个服务实体的加入和退出，外部负责集群地址向内部服务实体地址的装换，有的负载均衡器实现真正的负载均衡算法，有的只支持任务的转换，只实现任务转换的负载均衡器适用于支持ACTIVE-STANDBY的集群环境，在那里，集群中只有一个服务实体工作，当正在工作的服务实体发生故障时，负载均衡把后来的任务装箱另外一个服务实体


       内部通信：为了能协同工作，实现负载均衡和错误恢复，集群个实体间必须时常通信，比如负载均衡器对服务实体心跳测试信息，服务实体间任务执行上下文信息的通信

       具有同一个集群地址使得客户端能访问集群提供的计算服务，一个集群地址下隐藏了个各个服务实体的内部地址，使得客户要求的计算服务能在各个服务实体之间分布，内部通信是集群能正常运转的基础，它使得集群具有负载和错误恢复的能力


   集群的分类：
      高可用集群（High Availability Dluster）
      负载均衡集群（Load Balance Cluster）
      科学计算集群（High Preformance Computing Cluster）

  
  分布式与集群的联系和区别？
    
     分布式是指将不同的业务分布在不同的地方
     而集群指的是将几台服务器集中在一起，实现同一业务
  
     分布式中的每一个结点，都可以做集群
     而集群不一定是分布式的

     ex:新浪  访问人多 做一个集群，前面放一个响应服务器，后面几台服务器完成同一个业务，如果业务访问的时候，响应服务器看那台服务器的负载不是很重，就将给哪一台去完成

        而分布式，从窄意上理解，也跟集群差不同，但是它的组织比较松散，有一个组织性，一台服务器垮了，其他的服务器可以顶上来
        分布式的每一个结点，都完成不同的业务，一个节点垮了，那这个业务就不可访问了


---------------------------------------------------------------------------------------------------

35. 2进制32位带符号的int表值范围从-2147483648到2147483648

   
---------------------------------------------------------------------------------------------------

36. 理解restFul结构

    一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件，主要用于客户端和服务器交互类软件

    REST---Representational State Transfer  表现层状态转化


    主要的构成特点：
    
    资源（Resource） 表现层指的是资源的表现层  资源作为在网络上的一个实体，有唯一的URI

    表现层（Representation）资源的表现形式

    状态转化（State Transfer） 

        访问一个网站，代表了客户端和服务器的一个互动过程，在这个过程中，涉及到了数据和状态的变化，互联网的通信协议为HTTP协议，是一个无状态协议，这意味着，所有的状态都保存在服务器端，因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化（Stata Transfer）”。而这种转化是建立在表现层之上的，所以为“表现层状态转化”


    HTTP中表示操作方式的  GET POST PUT DELETE

    什么是RESTful架构：

    1）每一个URI代表一种资源
      
    2）客户端和服务器之间，传递这种资源的某种表现层

    3）客户端通过四个HTTP动词，对服务端资源进行操作，实现“表现成状态转化”


    一些常见的设计误区：
    1）URI包含动词
    
    2）在URI中加入版本号

    这些问题都可以在HTTP的首部字段中进行解决设置
    
---------------------------------------------------------------------------------------------------
37.log4j的日志级别

   WARN  表示会出现潜在错误的情形

   ERROR 指出虽然发生错误事件，但仍然不影响系统的继续运行

   FATAL 指出每个严重的错误事件将会导致应用程序的退出

   ALL   最低等级的，用于打开所有日志记录

   OFF   最高等级的，用于关闭所有日志记录

   从等级的高低排序：
   OFF FATAL ERROR WARN INFO DEBUG ALL

   建议使用四个级别：ERROR WARN INFO DEBUG

   日志级别在开发阶段设置成DEBUG 在生产阶段设置为INFO或者ERROR、
















