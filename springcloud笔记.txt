服务治理：Spring Cloud Eureka

   服务治理是微服务架构中最核心和基础的模块，主要用来实现各个微服务实例的自动化注册与发现

   
   服务注册： 在服务治理框架中，通常会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，注册中心按服务名分类组织服务清单；注册中心还需要以心跳的方式去监测清单中的服务是否可用，若不可用需要从服务清单中剔除，达到排除故障服务的效果

   
   服务发现：服务间的条用通过向服务名发起请求调用实现，但调用方在调用服务提供方接口的时候，并不知道具体的服务实例位置，所以需要向服务注册中心咨询服务，并获取所有服务的实例清单，以实现对具体服务实例的访问

   Eureka客户端，主要处理服务的注册与发现，客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约，同时，也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态

   
   搭建服务注册中心时，使用@EnableEurekaServer

   注册服务提供者：使用@EnableDiscoveryClient  注入DiscoveryClient  在配置文件中说明服务注册中心地址：eureka.client.serviceUrl.defaultZone



   高可用的注册中心，要充分考虑到发生故障的情况，此时注册中心将自己作为服务向其他服务注册中心注册自己，形成一组互相注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果。
 
   在配置高可用的注册中心，注意单个的eureka-server的配置  要配置禁止自己注册自己

   eureka.client.register-with-eureka=false   代表不向注册中心注册自己

   eureka.client.fetch-registry=false         不需要检索服务


   服务提供者在向高可用注册中心注册服务时需要制定所以注册中心的地址：

   eureka.client.serviceUrl.defaultZone=http://peer1:1001/eureka/,http://peer2:2002/eureka/



   服务消费者  主要完成两个目标：发现服务和消费服务

   服务发现的任务有Eureka的客户端完成，服务消费的任务由Ribbon完成

   Ribbon是一个基于HTTP和TCP的客户端负载均衡器，在通过客户端中配置的ribbonServerList服务端列表去轮询访问以达到负载均衡的作用

   Ribbon在Eureka服务发现的基础上，实现了一套对服务实例的选择策略，从而实现对服务的消费


   Spring Cloud Feign
  
   通过Feign来实现服务消费,Feign是基于Netflix Feign实现的声明式服务调用客户端
 
   通过@FeignClient定义的接口来统一的声明需要依赖的微服务接口，具体使用时跟调用本地方法的方式调用。Feign是基于Ribbon实现的，自带了客户端负载均衡功能


   
   


   服务注册中心，服务提供者，服务消费者的通信行为：

   服务提供者
   
   服务注册
  
   服务提供者在服务注册时，服务启动者在启动的时候通过REST请求将自身注册到Eureka Server中，携带自身的元数据，Eureka Server 接受到请求后将元数据存储在一个双层的map结构中，第一层的key为服务名，第二层的key是具体服务的实例名。
   
   在注册时，确保eureka.client.register-with-eureka=true


   服务同步

   当服务注册到高可用的eureka-server集群时，有多个注册中心，而注册中心之间是互相注册为服务的，所以当服务提供者将请求到一个服务注册中心时，会自动将请求转发给集群中的其他的注册中心，从而实现服务同步，可以从任意一个注册中心得到服务


   服务续约


   当服务提供者向注册中心注册完成后，会维护一个心跳来告诉Eureka Server仍然活着，防止注册中心将该服务实例从服务列表中排除出去，从这里看出注册中心会自动剔除无用的服务实例

   服务续约相关的两个配置：

   eureka.instance.lease-renewal-interval-in-seconds = 30  30s一次心跳通知

   eureka.instance.lease-expiration-duration-in-seconds = 90  90s后服务失效


   服务消费者

   获取服务

     启动服务消费者时，发送REST请求到服务注册中心，获取服务清单，Eureka Server维护一份只读服务清单返回给客户端，同时缓存清单会每隔30s更新一次

     可以通过eureka.client.registry-fetch-interval-seconds = 30 更改缓存清单的更新时间


   服务调用

     通过服务名获得具体服务提供者的实例和该实例的元数据信息，在Ribbon中采用轮询的方式调用来实现负载均衡

     Eureka中有Region和Zone的概念，一个Region包含多个Zone，每个服务客户端需要被注册到一个Zone中，所以每个客户端对应一个Region和一个Zone。在服务调用时，优先访问同一个Zone中欧的服务提供方

   
   服务下线

     当服务提供者正常关闭时，会向注册中心发送REST请求，告诉注册中心下线，服务端在接受到请求时会将该服务的状态设置为下线，并把下线事件传播

   
   服务注册中心
  
   失效剔除

     当服务提供者非正常关闭而不可用时，超过90s没有续约，Eureka Server在启动时会创建一个定时任务，默认60s剔除没有续约的服务

 

   自我保护

     在注册中心运行时，会统计心跳失败的比例在15分钟内是否低于85%，如果出现会有自我保护机制，将当前的实例注册信息保护起来，让实例不会过期，但是会出现问题，若保护期间实例出现问题，客户端拿到失效的服务，此时客户端必须要有容错机制，比如 使用请求重试 断路器等机制

     可以在注册中心通过eureka.server.enable-self-preservation=false来关闭保护机制



   配置

   在Eureka的服务治理体系中，主要分为服务端与客户端两个不同的角色，服务端为服务注册中心，而客户端为各个提供接口的微服务应用。
  
   Eureka客户端的配置对象存在于所有Eureka服务治理体系下的应用实例中，在使用springcloud时，主要的配置几乎都是对客户端的配置。

   客户端的配置主要分为两个方面：

      服务注册相关的配置信息，包括服务注册中心的地址，服务获取的间隔时间，可用区域等

      服务实例相关的配置信息，包括服务实例的名称，IP地址，端口号，健康检查路径等



   服务实例的元数据

    什么是元数据？

      它是Eureka客户端向服务注册中心发送注册请求（REST请求）时，用来描述自身的对象，包含标准化数据，如服务名称、实例名称、实例IP、实例端口和一些自定义的元数据信息

    
    实例名配置

      即InstanceInfo中的instanceId参数，它是区分同一服务中不同实例的唯一表示

   跨平台支持

    Eureka的通信机制使用了HTTP的REST接口实现，这也是Eureka同其他服务注册工具的一个关键不同点，由于HTTP的平台无关性，虽然Eureka Server通过java实现，但是在其下的微服务应用并不限于使用java进行开发


   客户端负载均衡：Spring Cloud Ribbon

     Ribbon是基于HTTP和TCP的客户端负载均衡工具，可以将面向服务的REST模板请求自动转换成客户端负载均衡的服务调用

     负载均衡包括硬件负载和软件负载，不管是硬件设备还是软件模块都会维护一个下挂可用的服务端清单，通过心跳检测来剔除故障的服务端节点以保证清单中都是可以正常访问的服务端节点，当请求到达时采用某种算法（线性轮询，按权重负载，按流量负载等）从维护的可用的服务端清单中取出一台服务端的地址，进行转发

     客户端负载均衡和服务端负载均衡最大的不同点在于服务清单所存储的位置，在客户端负载均衡中，需要所有的客户端节点都维护自己要访问的服务端清单，而清单来源于服务注册中心。客户端通过与服务注册中心配合采用心跳方式去维护服务清单的健康性


     采用Ribbon实现负载均衡：

     服务提供者需要启动多个服务实例并注册到一个注册中心或是多个相关联的服务注册中心

     服务消费者直接通过调用被@LoadBlanced注解修饰过的RestTemplate来实现面向服务的接口调用

   
    使用Feign上传文件时，由Feign-client提供服务，在handleFileUpload方法的参数中使用了@RequestPart注解得到参数MultipartFile, 服务消费者Feign-counsumer创建接口调用服务，在上传文件时，使用了DiskFileItem类，其中创建createItem是由fieldName属性，该属性必须与方法@RequestPart的value一致，否则无法上传，
	同时这个属性的值即为上传文件的文件名getName的值
	
	
	分布式配置中心  Spring Cloud Config 
	
	      作用：用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持
		   
		  结构：分为服务端和客户端两个部分
		             其中，服务端称为分布式配置中心，是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；
					 客户端则是微服务架构中的各个微服务应用或基础设施，通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息
					 
	     实现方式：配置中心默认使用Git来存储配置信息，所以使用Spring Cloud Config 构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，可以通过Git客户端工具来方便的管理和访问配置内容。
		  
		 客户端从服务端获取配置信息时报错：Fetching config from server at: http://localhost:8888
		 解决方法：将客户端的application.properties改为bootstrap.properties

		 在客户端动态刷新配置文件时，遇到Full authentication is required to access this resource. 
		 解决方法：management.security.enabled=false  由于client服务开启了权限拦截
		 
		 刷新时用/refresh没有作用
		 解决方法：在Controller上加@RreshScope注解
		 
    Hystrix服务容错保护
	    服务降级
	    通过在方法的注解@HystrixCommand(fallbackMethod="")来实现服务降级， 服务消费方调用服务，请求超时异常，服务消费者就通过HystrixCommand注解中指定的降级逻辑进行执行
		
		依赖隔离	Hystrix使用"舱壁模式"实现线程池的隔离，会每个Hystrix命令创建一个独立的线程池，在某个Hystrix命令包装下的依赖服务出现延迟过高的情况时，也只是对该依赖的调用产生影响，而不会拖慢其他服务
		当依赖的服务从失效恢复正常后，它的线程会被清理并且能够马上恢复健康的服务
		每个专有的线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问
		除了使用线程池外，还可以使用信号量来控制单个依赖服务的并发度，信号量的开销要比线程池小得多，但是不能设置超时和实现异步访问，所以，只有在依赖服务是足够可靠的情况下才使用信号量   
		两处支持信号量的使用： 命令执行  降级逻辑
		
	    依赖隔离和服务降级通过@HystrixCommand一体化实现
	
	    断路器器
		三个重要的参数：
		快照时间窗：断路器是否需要打开需要统计一段时间的请求和错误数据，这个时间范围就是快照时间窗，默认为最近10秒
		请求总数下限：在快照时间窗内，必须满足请求总数下线才有资格根据熔断，默认为20， 如在10秒内如果请求总数不超过20次，即使所有的请求都超时或者失败，断路器都不会打开
		错误百分比下限：当请求数在快照时间窗内超过下限，出现异常的情况达到离开错误的百分比下限，默认情况设定为50%，这时断路器就会打开
		
		当断路器打开时，请求调用不会再执行主逻辑，而是直接调用降级逻辑，通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果
		
		如何恢复原来的主逻辑：
		hystrix实现了自动恢复功能，当断路器打开，对主逻辑进行熔断后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑临时称为主逻辑，当休眠时间窗到期断路器将进入半打开的状态，释放一次请求到原来的主逻辑，若能够正常返回，那么路断器将继续闭合，主逻辑回复，否则断路器继续进入打开状态，休眠时间窗重新计时
		
		使用Hystrix Dashboard实现监控面板，
		
		使用Turbine做数据聚合   有两种方式 HTTP方式聚合和mq聚合
		
		
		使用Zuul做服务网关
		单实例配置  
		    通过zuul.routes.<route>.path与zuul.routes.<route>.url进行配置
			zuul.routes.user-service.path=/user-service/**
			zuul.routes.user-service.url=http://localhost:8080/
			该配置实现了对符合/user-service/**规则的请求路径转发到http://localhost:8080/地址的路由规则
			
		 多实例配置
		    通过path和serviceId 及<serviceId>.ribbon.listOfServers 进行配置，需要将ribbon.eureka.enabled设置为false
			该配置方式与服务路由的配置方式一样，采用了path和serviceId参数对的映射方式，只是serviceId是由用户手工命名的服务名称，配合<serviceId>.ribbon.listOfServers参数实现服务与实例的维护。 由于存在多个实力，API网关在 进行路由转发时需要实现负载均衡策略，需要Ribbon的配合，zuul中自带了对Ribbon的依赖，将ribbon.eureka.enabled设置为false,防止没有整合服务治理框架而找不到对应的实例清单
		
		服务路由配置
		    将Zuul与Eureka整合，实现对服务实例的自动维护，不需要像传统路由配置方式那样为serviceId去指定具体的服务实例地址，只需要通过一组zuul.routes.<route>.path与zuul.routes.<route>.serviceId参数对的方式配置即可
			
			zuul.routes.user-service.path = /user-service/**
			zuul.routes.user-service.serviceId=user-service
			
			还有一种更简洁的配置使用 zuul.routes.<serviceId>=<path>
			zuul.routes.user-service=/user-service/**
			这样的方式是将API网关也看做Eureka服务治理下的一个普通的微服务的应用，除了将自己注册到Eureka服务注册中心上之外，也会从注册中心获取所有服务及实例清单，所以在Eureka的帮助下，API网关服务本身就已维护了系统中所有serviceId与实例地址的映射关系，然后通过ribbon的负载均衡策略，进行路由转发
			
		zuul的拦截过滤功能(过滤器)
            将微服务应用的校验权限放到前置网关服务中完成，降低应用接口开发复杂度，减少冗余代码，易于维护
  
			实现方式：继承ZuulFilter抽象类并实现它定义的四个抽象函数
			
			filterType：过滤器的类型，决定过滤器在请求的哪个声明周期中执行  pre 代表会在请求路由之前执行
			
			filterOrder: 过滤器的执行顺序，当请求在一个阶段中存在多个过滤器时，需要根据该方法的返回值来依次执行
			
			shouldFilter:判断过滤器是否需要被执行，实际允许用中使用该函数来指定过滤器的有效范围
			
			run ： 过滤器的具体逻辑，通过 ctx.setSendZuulResponse(false)令zuul过滤该请求，不对其进行路由，然后通过ctx.setResponseStatusCode(401)设置了其返回的错误码，或者通过ctx.setResponseBody(body)对返回的内容进行编辑
			
			RequestContext ctx = RequestContext.getCurrentContext();
			HttpServletRequest request = ctx.getRequest();
			通过对request请求的参数进行校验
			
			
		Zuul包含了请求路由和请求过滤两个功能，路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础，而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。
		
		路由功能在实现时，它的路由映射和请求转发都是由几个不同的的过滤器完成的，其中路由映射主要通过pre类型的过滤器完成，它将请求路径与配置的路由规则进行匹配，找到需要转发的目标地址。而请求转发部分是route类型的过滤器来完成，对pre类型过滤器获得的路由地址进行转发。
		
		过滤器是zuul实现API网关功能的最核心的部件，每个进入Zuul的HTTP请求都经过一系列的过滤器处理链得到请求响应并返回给客户端
		
		过滤器包含4个特征： 过滤类型  执行顺序  执行条件  具体操作  对应四个抽象方法
		
		filterType：过滤器的类型   
		    pre 在请求被路由之前调用
			routing  在路由请求时被调用
			error  处理请求发生错误时调用
			post  在routing和error过滤器之后被调用
			
		filterOrder: 通过int值来定义过滤器的执行顺序，数值越小优先级越高
		
		shouldFilter：返回一个boolean类型来判断过滤器是否要执行，通过此方法指定过滤器的有效范围
		
		run：过滤器的具体逻辑  在该函数中实现自定义的过滤逻辑
		
		
	Spring Cloud Stream 
	    用来为微服务应用构建消息驱动能力的框架，使用Spring Integration来连接消息代理中间件产品提供了个性化的自动化配置实现，引入了发布-订阅、消费组及消息分区三个核心概念
		
		绑定器
			通过定义绑定器作为中间层，实现了应用程序与消息中间件细节之间的隔离，通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。
		
		发布-订阅		
			到消息投递到消息中间件后，会通过共享的Topic主体进行广播，消息消费者在订阅的主题中收到它并触发自身的业务逻辑处理。
			Topic主题是springcloud stream中的一个抽象的概念，用来代表发布共享消息给消费者的地方。在不同的消息中间件中，Topic对应着不同的概念，如 在RabbitMQ中代表了fanout Exchange,而在kafka中则对应了kafka中的Topic
			
			此时，当消息发送到中间件时，所有的消费者都可以得到消息的副本。相对于点对点队列实现的消费通信来说，springcloud stream采用的发布-订阅模式可以有效的降低消息生产者和消费者之间的耦合。
			
		消费组
		    在发布-订阅的模式中，消息会得到所有消费者的消费操作，当每个微服务应用部署多个实例时，就会出现重复消费的情况。为了避免这种情况，springcloud stream 提供了消费组的概念
			
			通过spring.cloud.stream.bindings.input.group属性为应用指定一个组名，这样这个应用的多个实例在接受到消息的时候，只会有一个成员真正的收到消息并进行处理。
			
		
		消息分区
			在消息组中，每个消息都能保证只有被一个实例进行消费，但是无法控制消息具体被哪个实例进行消费。而消息分区的概念，就是解决这样的问题：当生产者将消息数据发给多个消费者实例的时候，保证拥有共同的特征的消息数据始终是由一个消费者实例接受和处理
			
		
	Spring Cloud Sleuth
	     分布式服务追踪   
		 Trace ID  标识一条请求链路
		 Span ID 表示一个基本的工作单元  比如：发送一个HTTP请求
		 
		 为实现请求追踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一表示，直到返回给请求方为止。这个标识为Trace ID
		 
		为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一的标识来标记它的开始、具体过程以及结束。 这个标识为Span ID , 对于每个Span，必须要有开始和结束两个节点。
		通过记录开始span和结束span的时间戳，统计出该Span的时间延迟，除了时间戳记录外，还可以包含一些其他数据，如事件名称，请求信息等
		
		
		 
                
		
		
		















