数据库分为关系型数据库和非关系型数据库
  
  关系型数据库：安全，容易理解，但比较浪费空间
  非关系型数据库：效率高，不安全（断电丢失）

SQL分为三部分：
 DDL：Data Definition Language，数据定义语言，用来维护存储数据的结构（数据库，表）代表指令：create drop alter等
 DML: Data Manipulation Language,数据操作语言，用来对数据进行操作（数据表中的内容），代表指令：insert delete update等
  其中DML内部又单独进行了一个分类：DQL（Data Query Language:数据查询语言 如select）
 DCL：Data Control Language 数据控制语言，只要时负责权限管理（用户），代表指令：grant revoke 等


 其中 DML语言需要事务管理

数据库操作： create alter drop 

表操作：
  新增 create table 表名（字段名 数据类型，……最后一行不需要逗号）[表选项];
  表选项：控制表的表现
    字符集：charset/character set 具体字符集；保证表中数据存储的字符集
    校对集：collate 具体校对集
    存储引擎：engine 具体的存储引擎（innodb和myisam）

  查看表
   show tables;
   show tables like '%s';查看以s结尾的表
   show create table student \g  ----\g==;
   show create table student \G  ----将查到的结构旋转90度变成纵向
   DESC class;
   describe class;
   show columns from class;  查看表结构

  重新命名表
  rename table student to my_student;
  修改表选项： 字符集 校对集 和存储引擎
  Alter table 表名 

  修改字段 新增 修改 删除 重名 删除
  新增
   alter table 表名 add 字段名 数据类型 [列属性][位置];
   位置：字段名可以存放表中的任意位置
        First：第一个位置
        After：在哪个字段之后：after 字段名 默认的是在最后一个字段之后
  
  修改  修改通常是是修改属性或者数据类型
   alter table 表名 modify 字段名 数据类型[属性][位置];

  重命名
  alter table 表名 change 旧字段名 新字段名 数据类型 [属性][位置];

  删除  是不可逆的
  alter table 表名 drop 字段名;

  删除表 可一次删除多张表
  Drop table（表名）；

  数据操作
  新增数据
   1）给全表字段插入数据，不需要指定字段列表，要求数据的值出现的顺序必须与表中设计字段的顺序相同。凡是非数值数据，都是用单引号
   2）给部分字段插入数据，需要选定字段列表，字段列表出现的顺序与字段的顺序无关，但是值列表的顺序必须与选定的字段的顺序一致
    
   insert into table (字段列表）values（值列表）；

  查看数据
  select */字段列表 from talbe(where 条件);

  更新数据
  update table set 字段=值 [where 条件];
  更新不一定会成功，比如没有要更新的真正的数据

  删除数据
  delete from table where..;
  
  中文 问题
  查看服务器支持的字符集
  show character set;
 
  查看服务器当前使用的字符集
  show variables like 'character_set%';
 
  设置字符集的快捷方式 set names 字符集；
  

  校对集问题
  校对集 数据比较的方式
  有三种格式：
   _bin:binary 二进制比较，取出二进制位，一位一位的比较，区分大小写
   _cs:case sensitive 大小写敏感 区分大小写
   _ci:case insensitive 大小写不敏感 不区分大小写

   必须在没有数据之前声明好，如果有数据声明无效
   
  定长字符串 char（L） 单位为字符 最大长度值可以为255
  变长字符串 varchar（L）理论长度是65536个字符，但是会多1到2个字节来确定存储的实际长度，但是实际上如果长度超过255，既不用定长也不用变长，使用文本字符串text

  如何选择定长或者是变长字符串
  定长的磁盘空间比较浪费，但是效率高，如果数据基本上确定长度都一样，就使用定长，如身份证，手机号码等
  
  变长的磁盘空间比较节省，但是效率低，如果数据不能确定长度使用变长，如名字，地址等

  文本字符串
    格式有text blob
    text 存储文字 
    blob 存储二进制数据

  
  索引  系统根据某种算法，将已有的数据（未来可能新增的数据）单独建立一个文件，文件能够实现快速的匹配数据，并能够快速的找到对应表中的记录
  mysql提供多种索引：
    主键索引 primary key  
    唯一索引 unique key  
    全文索引 fulltext key 针对文章内部的关键字进行索引  最大问题：如何确定关键字  中文分词（sphinx）
    普通索引 index

  范式  Normal Format
  是为了解决一种数据的粗出与优化的问题，保存数据的存储之后，凡是能够通过关系寻找出来的数据，坚决不再重复，终极目标是减少数据冗余
  是一种分层结构的规范，分为六层 每一层都比上一层更加严格，若要满足下一层范式，前提是满足上一层范式
   
  范式只为解决空间问题，所以数据库的设计又不可能完全按照范式的要求实现，一般情况下，只有前三种范式需要满足

  1NF： 数据必须具有原子性

  2NF：在数据表设计的过程中，如果有复合主键（多字段主键），且表中有字段并不是由整个主键来取定，而是依赖主键中的某个字段（主键的部分），存在字段依赖主键的部分的问题，称之为部分依赖，2NF就是要解决表设计不允许出现部分依赖。
  解决方法：1）单独成表 将复合主键与依赖的字段单独成表   2）设置逻辑主键 ex: 设置id

  3NF：理论上讲，应该一张表中的所有字段都应该直接依赖主键（逻辑主键：代表的时业务主键），如果表设计中存在一个字段，并不直接依赖主键，而是通过某个非主键字段依赖，最终实现依赖主键，把这种不是直接依赖主键，而是依赖非主键字段的依赖关系称之为传递依赖。
   3NF就是要解决传递依赖的问题‘
  解决方案：将存在传递依赖的字段，以及依赖的字段本身单独取出，形成一个单独的表，然后在需要对应的信息的时候，使用对应的实体表的主键加进来

  逆规范化
  在设计表的时候，如果一张表中有几个字段是需要从另外的表中去获取信息，理论上讲，的确可以获取到想要的数据，但是效率会降低，会刻意的在某些表中，不去保存另外表的主键（逻辑主键），而是直接保存想要的数据信息，这样一来，在查询数据的时候，一张表刻意直接提供数据，而不需要多表查询（效率低），但是会导致数据冗余增加
 
  逆规范化就是磁盘利用率与效率的对抗
  

  蠕虫复制：
  从已有的数据中获取数据，然后将数据又进行新增操作，数据成倍增加

  表创建高级操作： 从已有表创建新表(复制表结构） CREATE TABLE 表名 LIKE 数据库.表名;

  蠕虫复制：先查数据，然后将查出的数据新增一遍
  insert into 表名[（字段名)] select 字段列表/* from 数据表名;

  蠕虫复制的意义： 1） 从已有表拷贝数据到新表中 2）可以迅速的让表中的数据膨胀到一定的数量级：测试表的压力及效率


  视图：
  1）视图可以节省sql语句，将一条复杂的查询语句使用视图进行保存，以后可以直接对视图进行操作
  
  2）数据安全：视图操作是主要针对查询的，如果对视图结构进行处理（删除），不会影响基表数据(相对安全）
 
  3）视图往往是在大项目中使用，而且是多系统使用，可以对外提供有用的数据，但是隐藏关键（无用）的数据，数据安全
  
  4）视图可以对外提供友好型，不同的视图提供不同的数据，对外好像专门设计
  
  5）视图可以更好的进行权限控制

   新增数据：只能向单表插入数据，但是视图中包含的字段必须有基表中所有不能为空（或者设有默认值）字段，不能向有联合表中的视图插入数据

   视图算法：系统对视图以及外部查询视图的select语句的一种解析方式

     算法分为三种：
      Undefined: 未定义（默认的），这不是一种实际使用算法，是一种推卸责任的算法，告诉系统，视图没有定义算法，系统自己看着办

      Temptable：临时表算法 系统应该执行视图的select语句，后执行外部查询语句

      Merge：合并算法  系统应该先将视图对应的select语句与外部查询视图的select语句进行合并，然后执行（效率高）
    
     算法指定 在创建视图的时候
      CREATE ALGORITHM=指定算法 view 视图名 AS SELECT 语句；

     算法选择：如果视图的select语句中包含一个查询子句（五子句），而且很有可能顺序比外部的查询语句要靠后，一定要使用算法temptable，其它情况可以不用指定（默认即可）


 备份：
   数据表备份
   myisam和innodb数据存储方式：
       Innodb：只有表结构，数据全部存储到ibdata1文件中
       Myisam：表，数据和索引全部单独分开存储
        文件备份通常适用于myisam存储引擎，直接复制三个文件即可   比较适用于数据库的迁移


   单表数据备份：每次只能备份一张表，只能备份数据（表结构不能备份）

     通常的使用：将表中的数据进行到处到文件
  
    备份：从表中选出一部分数据保存到外部文件中（outfile）  
    语句格式： SELECT */字段列表 INTO OUTFILE 文件所在路径 FROM 数据源；--前提：外部文件不存在

    高级备份：自己指定字段和行的处理方式
      SELECT */字段列表 INTO OUTFILE 文件所在路径 FIELDS 字段处理 LINES 行处理 FROM 数据源；

        FIELDS:字段处理
            Enclosed by:字段使用什么内容包裹，默认使'',空字符串
            Terminated by：字段以什么结束，默认使"/t".tab键
            Escaped by：特殊符号用什么方式处理，默认是'\\',使用反斜杠转义
        LINES:行处理
            Starting by：每行以什么开始，默认是'',空字符串
            Terminated by：每行以什么结束，默认是"\r\n",换行符

    数据还原：将一个在外部保存的数据重新恢复到表中（如果表结构不存在，则无法还原）
      LOAD DATA INFILE 文件所在路径 INTO TABLE 表名[(字段列表)] FIELDS 字段处理 LINES 行处理; ----怎么备份的怎么还原

    
    SQL备份：
       备份的是sql语句，系统会对表结构以及数据进行处理，变成对应的sql语句，然后进行备份，还原的时只要执行sql指令即可（主要就是针对表结构）
 
       备份：mysql没有提供备份指令，需要利用mysql提供的软件：mysqldump.exe
       Mysqldump.exe也是一种客户端，需要操作服务器，必须连接认证
       Mysqldump/mysqldump.exe -hPup (h:host P:prot u:username p:password)数据库名字[数据表名字1[数据表名2]]>外部文件目录   （使用后缀名.sql)
       整库备份   Mysqldump/mysqldump.exe -hPup 数据库名字>外部文件目录


       SQL还原数据  两种
       1）使用mysql.exe 客户端还原
          Mysql.exe/mysql -hPup 数据库名字 < 备份文件目录
   
       2）使用SQL指令还原
          Source 备份文件所在路径
       
       SQL备份优缺点
         优：可以备份结构     缺：会浪费空间 （额外的增加SQL指令）

       增量备份：不是针对数据或者SQL指令进行备份，是针对mysql服务器的日志文件进行备份

            通过指定时间段进行备份，备份数据不会重复，而且所有的操作都会备份（大项目都用增量备份）
       

      


和其它数据库相比，MySQL有点不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离，这种架构可以根据业务的需求和实际需要选择适合的存储的引擎。


MySQL的逻辑架构

1）连接层
  最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似TCP/IP的通信，主要完成一些类似于连接处理，授权认证，及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全连接。服务器也会为安全接入的每个客户段验证它所具有的操作权限。

2）服务层
   第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程，函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作，如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量的读操作的环境中能过很好的提升系统的性能。

3）引擎层
   存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取，

4) 存储层
   数据存储层，主要是将数据存储在运行与裸设备的文件系统上，并完成与存储引擎的交互。


SQL性能下降的原因分析：
  性能下降SQL慢 执行时间长  等待时间长

  可能的原因：   查询语句写的太烂   索引失效（单值  复合）  关联查询太多join （设计缺陷或不得已的需求）   服务器调优及各个参数设置（缓冲 线程数等）

SQL执行顺序: 机读时， 是从From开始。


 MySQL常见瓶颈：

   CPU:CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候
   IO:磁盘IO瓶颈发生在装入数据远大于内存容量的时候
   服务器硬件的性能瓶颈： top,free,iostat和vmstat来查看系统的性能状态
   
   MySQL查询优化：
   explain：
   作用： 表的读取顺序  数据读取操作的操作类型  哪些所以可以使用  哪些索引被实际使用  表之间的引用  每张表有多少行被优化器查询


   索引优化

   两表优化： 左连接索引加在右表  右连接索引加在左表  交叉建索引

   小表驱动大表

   全值匹配

   最左前缀法则 指的是查询时从索引的最左列开始且不能跳过索引中的列

   不在索引上做任何操作（计算，函数，（自动or手动）类型转换），会导致索引失效而转向全表扫描

   存储引擎不能使用索引中范围条件右边的列（即索引中出现范围（除了 like 'xx%'，范围列右边列失效）

   尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *

   mysql在使用不等于的时候无法使用索引会导致全表扫描

   is null ,is not null 也无法使用索引

   like 以通配符开头（'%abc...')mysql索引失效会变成全表扫描的操作  （%只能加在右边  ex: where name like '王%';) 使用两边索引失效，为避免失效应尽量覆盖索引（即查询的列为建索引的列）

   字符串不加单引号索引失效
   
   少用or，用它来连接时索引失效

   优化原则：
   小表驱动大表，即小的数据集驱动大的数据集   关键字  in exists  （exists就是in的一种替代）

   select ..from table where exists(subquery)  该语法可以理解为：将主查询的数据，放到子查询中条件验证，根据验证结果（true或false）来决定主查询的数据结果是否得以保留

   排序优化

   ORDER BY字句，尽量使用Index方式排序，避免使用FileSort方式排序，尽量在索引列上完成排序操作，遵照索引的最佳左前缀
   
   如果不在索引列上，filesort有两种算法：

   双路排序

     MySQL4.1之前，使用的是双路排序，就是扫描两次磁盘，最终得到数据
 
     读取行指针和orderby列，对它们进行排序，然后扫描已经排序好的列表，按照列表的值重新从列表中读取对应的数据输出

   单路排序
     从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快些，避免了第二次读取数据，并且把随机IO变成了顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了

   单路排序可能出现的问题：当sort_buffer容量不够时，会导致大量的IO操作。

   优化策略：增大sort_buffer_size参数的设置    增大max_length_for_sort_data参数的设置   


   GROUP BY关键字优化：
   
     group by实质是先排序后进行分组，遵照索引建的最佳左前缀，当无法使用索引时，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置，where高于having，能写在where的限定条件就不要去having中限定

查询截取：
  慢查询日志

   是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。

   默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数，如果不是调优的需要，不建议启动该参数，因为会带来一定的性能影响
   使用set global slow_query_log=1开启了慢查询日志只对当前数据库生效，如果重启MySQL后就会失效，如果要永久生效，必须修改配置文件my.cnf，一般不建议这样做

   日志分析工具mysqldumpslow

   批量数据脚本  关键是创建函数 调用函数

   Show Profile 是mysql提供可以用来分析当前会话中语句执行的资源消耗情况，可以用于sql的调优的测量

   全局查询日志  在测试时使用


mysql锁机制
   分为 表锁 行锁  页锁

   表锁（偏读） ：偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生所冲突的概率最高，并发度最低

   读锁：
   对表加锁为当前session，当前session可以读当前表数据，但是不可以更改该当前表数据，不可以查询其它表，其它session可以查询上锁的表数据，也可以查询更新其它表，但是不可以更新上锁的表，会一直阻塞（极大影响性能）直到表的锁被释放。

   写锁： 会阻塞其它进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作

   读锁会阻塞写，但是不会堵塞读，而写锁则会把读和写都堵塞

   行锁（偏写）：偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发读也最高。

   InnoDB与MyISAM的最大不同有两点：一是支持事务  二是采用了行级锁

   索引失效行锁升级为表锁  varchar 类型不加' '会导致严重问题

   加行锁：
     begin;
      select xxx for update;锁定某一行后，其它操作会被阻塞，直到锁定行的会话提交commit
     commit;
   
   优化建议：
    1）尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
    2）合理设计索引，尽量缩小锁的范围
    3）尽可能较少检索条件，避免间隙锁
    4）尽量控制事务大小，减少锁定资源量和时间长度
    5）尽可能低级别事务隔离



    悲观锁

    从数据开始更改时就将数据锁住，直到更改完成才释放

    缺点: 可能会造成加锁的时间很长，并发性不好，特别是长事务，影响系统的整体性能

    实现方式：基于数据库的锁机制实现


    乐观锁
   
    直到修改完成准备提交所做的修改到数据库的时候才会将数据锁住

    优点：加锁时间短，提高了大并发量下的系统整体性能表现

    实现方式：

    1）基于版本记录机制实现，需要为每一行数据增加一个版本标识，每次更新数据都要更新对应的版本号+1

    2）使用时间戳来实现，与version相似

    工作原理：读出数据时，将此版本号一同读出，之后更新时，对此版本号加一，如果提交的数据版本号大于数据库表当前的版本号，则予以更新


mysql的主从复制

  分为几种方式：
   同步复制：主服务器将更新的数据写入到它的二进制日志（Binlog）文件中后，必须等待验证所有的从服务器的更新数据是否已经复制到其中，之后才可以自由处理其他进入的事务处理请求

   异步复制：主服务器将它更新的数据写入到二进制日志后，无需等待验证更新数据是否已经复制到从服务器中，就可以自由处理其他进入的事务处理请求

   
   半同步复制：主服务器更新后，只需要等待验证一台从服务器的更新数据是否已经复制，其他从服务器不用管，就可以自由处理其他的事务请求



 MySql的分页实现： 使用limit   为mysql的内置函数，其作用是用于限制查询结果的条数   limit[位置偏移量]，行数

   select * from table limit m,n;

   其中m是指记录开始的index,从0开始，表示第一条记录，n是指从第m+1条开始，取n条



 数据库的优化思路：在现有数据库难以承受读写压力时，进行数据库的优化

  1）首先进行数据的读写分离，设置主从结构，主写从读
  
  2）垂直分区分库，将不同的表放在不同的库中，针对每个库，也可进行读写分离的设置

  3）水平分区分表 将表进行拆分
   
  4）NOSQL数据库的使用 （缓存的使用）


